{"created": 1754582887.3235843, "duration": 106.83321332931519, "exitcode": 1, "root": "C:\\Projects\\building-os-platform\\tests\\api", "environment": {}, "summary": {"passed": 19, "failed": 14, "total": 33, "collected": 33}, "collectors": [{"nodeid": "", "outcome": "passed", "result": [{"nodeid": "__init__.py", "type": "Package"}]}, {"nodeid": "test_endpoints.py::TestPayloads", "outcome": "passed", "result": []}, {"nodeid": "test_endpoints.py::TestHealthEndpoint", "outcome": "passed", "result": [{"nodeid": "test_endpoints.py::TestHealthEndpoint::test_health_check_success", "type": "Function", "lineno": 14}, {"nodeid": "test_endpoints.py::TestHealthEndpoint::test_health_check_performance", "type": "Function", "lineno": 23}]}, {"nodeid": "test_endpoints.py::TestDirectorEndpoint", "outcome": "passed", "result": [{"nodeid": "test_endpoints.py::TestDirectorEndpoint::test_director_basic_request", "type": "Function", "lineno": 37}, {"nodeid": "test_endpoints.py::TestDirectorEndpoint::test_director_with_user_request", "type": "Function", "lineno": 46}, {"nodeid": "test_endpoints.py::TestDirectorEndpoint::test_director_with_user_id", "type": "Function", "lineno": 56}]}, {"nodeid": "test_endpoints.py::TestPersonaEndpoint", "outcome": "passed", "result": [{"nodeid": "test_endpoints.py::TestPersonaEndpoint::test_persona_valid_message", "type": "Function", "lineno": 68}, {"nodeid": "test_endpoints.py::TestPersonaEndpoint::test_persona_missing_user_id", "type": "Function", "lineno": 81}, {"nodeid": "test_endpoints.py::TestPersonaEndpoint::test_persona_missing_message", "type": "Function", "lineno": 89}, {"nodeid": "test_endpoints.py::TestPersonaEndpoint::test_persona_conversations", "type": "Function", "lineno": 97}]}, {"nodeid": "test_endpoints.py::TestElevatorEndpoint", "outcome": "passed", "result": [{"nodeid": "test_endpoints.py::TestElevatorEndpoint::test_elevator_call_basic", "type": "Function", "lineno": 109}, {"nodeid": "test_endpoints.py::TestElevatorEndpoint::test_elevator_missing_mission_id", "type": "Function", "lineno": 120}]}, {"nodeid": "test_endpoints.py::TestPSIMEndpoint", "outcome": "passed", "result": [{"nodeid": "test_endpoints.py::TestPSIMEndpoint::test_psim_search_basic", "type": "Function", "lineno": 132}, {"nodeid": "test_endpoints.py::TestPSIMEndpoint::test_psim_search_with_custom_query", "type": "Function", "lineno": 142}]}, {"nodeid": "test_endpoints.py::TestCoordinatorEndpoint", "outcome": "passed", "result": [{"nodeid": "test_endpoints.py::TestCoordinatorEndpoint::test_coordinator_mission_status", "type": "Function", "lineno": 155}, {"nodeid": "test_endpoints.py::TestCoordinatorEndpoint::test_coordinator_different_mission_id", "type": "Function", "lineno": 166}]}, {"nodeid": "test_endpoints.py::TestCORSHeaders", "outcome": "passed", "result": [{"nodeid": "test_endpoints.py::TestCORSHeaders::test_cors_headers_present[/health]", "type": "Function", "lineno": 178}, {"nodeid": "test_endpoints.py::TestCORSHeaders::test_cors_headers_present[/director]", "type": "Function", "lineno": 178}, {"nodeid": "test_endpoints.py::TestCORSHeaders::test_cors_headers_present[/persona]", "type": "Function", "lineno": 178}, {"nodeid": "test_endpoints.py::TestCORSHeaders::test_cors_headers_present[/elevator/call]", "type": "Function", "lineno": 178}, {"nodeid": "test_endpoints.py::TestCORSHeaders::test_cors_headers_present[/psim/search]", "type": "Function", "lineno": 178}, {"nodeid": "test_endpoints.py::TestCORSHeaders::test_cors_headers_present[/coordinator/missions/test-123]", "type": "Function", "lineno": 178}]}, {"nodeid": "test_endpoints.py::TestErrorHandling", "outcome": "passed", "result": [{"nodeid": "test_endpoints.py::TestErrorHandling::test_invalid_endpoint", "type": "Function", "lineno": 220}, {"nodeid": "test_endpoints.py::TestErrorHandling::test_invalid_method", "type": "Function", "lineno": 225}, {"nodeid": "test_endpoints.py::TestErrorHandling::test_malformed_json", "type": "Function", "lineno": 235}]}, {"nodeid": "test_endpoints.py", "outcome": "passed", "result": [{"nodeid": "test_endpoints.py::TestPayloads", "type": "Class"}, {"nodeid": "test_endpoints.py::TestHealthEndpoint", "type": "Class"}, {"nodeid": "test_endpoints.py::TestDirectorEndpoint", "type": "Class"}, {"nodeid": "test_endpoints.py::TestPersonaEndpoint", "type": "Class"}, {"nodeid": "test_endpoints.py::TestElevatorEndpoint", "type": "Class"}, {"nodeid": "test_endpoints.py::TestPSIMEndpoint", "type": "Class"}, {"nodeid": "test_endpoints.py::TestCoordinatorEndpoint", "type": "Class"}, {"nodeid": "test_endpoints.py::TestCORSHeaders", "type": "Class"}, {"nodeid": "test_endpoints.py::TestErrorHandling", "type": "Class"}]}, {"nodeid": "test_performance.py::TestPerformance", "outcome": "passed", "result": [{"nodeid": "test_performance.py::TestPerformance::test_response_time_under_threshold", "type": "Function", "lineno": 18}, {"nodeid": "test_performance.py::TestPerformance::test_concurrent_health_checks", "type": "Function", "lineno": 45}]}, {"nodeid": "test_performance.py::TestLoadTesting", "outcome": "passed", "result": [{"nodeid": "test_performance.py::TestLoadTesting::test_sustained_load_health_endpoint", "type": "Function", "lineno": 72}]}, {"nodeid": "test_performance.py::TestStressScenarios", "outcome": "passed", "result": [{"nodeid": "test_performance.py::TestStressScenarios::test_large_payload_persona", "type": "Function", "lineno": 149}, {"nodeid": "test_performance.py::TestStressScenarios::test_rapid_successive_requests", "type": "Function", "lineno": 163}, {"nodeid": "test_performance.py::TestStressScenarios::test_special_characters_in_requests", "type": "Function", "lineno": 189}]}, {"nodeid": "test_performance.py::TestBoundaryConditions", "outcome": "passed", "result": [{"nodeid": "test_performance.py::TestBoundaryConditions::test_empty_payloads", "type": "Function", "lineno": 213}, {"nodeid": "test_performance.py::TestBoundaryConditions::test_null_values_in_payload", "type": "Function", "lineno": 224}, {"nodeid": "test_performance.py::TestBoundaryConditions::test_extremely_long_mission_id", "type": "Function", "lineno": 233}]}, {"nodeid": "test_performance.py", "outcome": "passed", "result": [{"nodeid": "test_performance.py::TestPerformance", "type": "Class"}, {"nodeid": "test_performance.py::TestLoadTesting", "type": "Class"}, {"nodeid": "test_performance.py::TestStressScenarios", "type": "Class"}, {"nodeid": "test_performance.py::TestBoundaryConditions", "type": "Class"}]}, {"nodeid": "__init__.py", "outcome": "passed", "result": [{"nodeid": "test_endpoints.py", "type": "Module"}, {"nodeid": "test_performance.py", "type": "Module"}]}], "tests": [{"nodeid": "test_endpoints.py::TestHealthEndpoint::test_health_check_success", "lineno": 14, "outcome": "passed", "keywords": ["test_health_check_success", "TestHealthEndpoint", "test_endpoints.py", "__init__.py", "api"], "setup": {"duration": 0.04278170000179671, "outcome": "passed", "stdout": "\n\ud83e\uddea Starting BuildingOS API Test Suite\n\ud83c\udf10 Base URL: https://pj4vlvxrg7.execute-api.us-east-1.amazonaws.com\n\ud83c\udff7\ufe0f  Environment: dev\n"}, "call": {"duration": 2.539462900000217, "outcome": "passed", "stdout": "\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 2536.70ms | \ud83d\udce6 Size: 60 bytes\n"}, "teardown": {"duration": 0.0010225000005448237, "outcome": "passed", "stdout": "\n"}}, {"nodeid": "test_endpoints.py::TestHealthEndpoint::test_health_check_performance", "lineno": 23, "outcome": "passed", "keywords": ["test_health_check_performance", "TestHealthEndpoint", "test_endpoints.py", "__init__.py", "api"], "setup": {"duration": 0.0006786999983887654, "outcome": "passed"}, "call": {"duration": 0.19941090000065742, "outcome": "passed", "stdout": "\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 196.97ms | \ud83d\udce6 Size: 60 bytes\n"}, "teardown": {"duration": 0.0010621000001265202, "outcome": "passed", "stdout": "\n"}}, {"nodeid": "test_endpoints.py::TestDirectorEndpoint::test_director_basic_request", "lineno": 37, "outcome": "passed", "keywords": ["test_director_basic_request", "TestDirectorEndpoint", "test_endpoints.py", "__init__.py", "api"], "setup": {"duration": 0.00068950000058976, "outcome": "passed"}, "call": {"duration": 4.475104799999826, "outcome": "passed", "stdout": "\n\ud83d\ude80 GET /director\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 4472.80ms | \ud83d\udce6 Size: 128 bytes\n"}, "teardown": {"duration": 0.0008335000020451844, "outcome": "passed", "stdout": "\n"}}, {"nodeid": "test_endpoints.py::TestDirectorEndpoint::test_director_with_user_request", "lineno": 46, "outcome": "passed", "keywords": ["test_director_with_user_request", "TestDirectorEndpoint", "test_endpoints.py", "__init__.py", "api"], "setup": {"duration": 0.0005467000009957701, "outcome": "passed"}, "call": {"duration": 6.553137800001423, "outcome": "passed", "stdout": "\n\ud83d\ude80 GET /director?user_request=Test mission from Python API tests\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 6550.35ms | \ud83d\udce6 Size: 128 bytes\n"}, "teardown": {"duration": 0.0009016000003612135, "outcome": "passed", "stdout": "\n"}}, {"nodeid": "test_endpoints.py::TestDirectorEndpoint::test_director_with_user_id", "lineno": 56, "outcome": "passed", "keywords": ["test_director_with_user_id", "TestDirectorEndpoint", "test_endpoints.py", "__init__.py", "api"], "setup": {"duration": 0.0005147000010765623, "outcome": "passed"}, "call": {"duration": 4.706507499999134, "outcome": "passed", "stdout": "\n\ud83d\ude80 GET /director?user_id=api-test-user\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 4704.11ms | \ud83d\udce6 Size: 128 bytes\n"}, "teardown": {"duration": 0.0007613000016135629, "outcome": "passed", "stdout": "\n"}}, {"nodeid": "test_endpoints.py::TestPersonaEndpoint::test_persona_valid_message", "lineno": 68, "outcome": "failed", "keywords": ["test_persona_valid_message", "TestPersonaEndpoint", "test_endpoints.py", "__init__.py", "api"], "setup": {"duration": 0.0004671000024245586, "outcome": "passed"}, "call": {"duration": 0.4711798999996972, "outcome": "failed", "crash": {"path": "c:\\Projects\\building-os-platform\\tests\\api\\test_endpoints.py", "lineno": 74, "message": "assert 202 == 200\n +  where 202 = <Response [202]>.status_code"}, "traceback": [{"path": "test_endpoints.py", "lineno": 74, "message": "AssertionError"}], "stdout": "\n\ud83d\ude80 POST /persona\n\ud83d\udcca Status: 202 | \u23f1\ufe0f  Time: 468.62ms | \ud83d\udce6 Size: 135 bytes\n", "longrepr": "self = <api.test_endpoints.TestPersonaEndpoint object at 0x00000241A55A6850>\n\n    def test_persona_valid_message(self):\n        \"\"\"Test persona with valid message\"\"\"\n        payload = TestPayloads.persona_message()\n        response, data = client.post(\"/persona\", json=payload)\n    \n>       assert response.status_code == 200\nE       assert 202 == 200\nE        +  where 202 = <Response [202]>.status_code\n\ntest_endpoints.py:74: AssertionError"}, "teardown": {"duration": 0.0010665999980119523, "outcome": "passed", "stdout": "\n"}}, {"nodeid": "test_endpoints.py::TestPersonaEndpoint::test_persona_missing_user_id", "lineno": 81, "outcome": "passed", "keywords": ["test_persona_missing_user_id", "TestPersonaEndpoint", "test_endpoints.py", "__init__.py", "api"], "setup": {"duration": 0.0006413999981305096, "outcome": "passed"}, "call": {"duration": 0.2003487000001769, "outcome": "passed", "stdout": "\n\ud83d\ude80 POST /persona\n\ud83d\udcca Status: 400 | \u23f1\ufe0f  Time: 198.11ms | \ud83d\udce6 Size: 45 bytes\n"}, "teardown": {"duration": 0.0007679000009375159, "outcome": "passed", "stdout": "\n"}}, {"nodeid": "test_endpoints.py::TestPersonaEndpoint::test_persona_missing_message", "lineno": 89, "outcome": "passed", "keywords": ["test_persona_missing_message", "TestPersonaEndpoint", "test_endpoints.py", "__init__.py", "api"], "setup": {"duration": 0.00044659999912255444, "outcome": "passed"}, "call": {"duration": 0.20007690000056755, "outcome": "passed", "stdout": "\n\ud83d\ude80 POST /persona\n\ud83d\udcca Status: 400 | \u23f1\ufe0f  Time: 197.93ms | \ud83d\udce6 Size: 45 bytes\n"}, "teardown": {"duration": 0.0010889000004681293, "outcome": "passed", "stdout": "\n"}}, {"nodeid": "test_endpoints.py::TestPersonaEndpoint::test_persona_conversations", "lineno": 97, "outcome": "failed", "keywords": ["test_persona_conversations", "TestPersonaEndpoint", "test_endpoints.py", "__init__.py", "api"], "setup": {"duration": 0.000597800000832649, "outcome": "passed"}, "call": {"duration": 6.949648000001616, "outcome": "failed", "crash": {"path": "C:\\Projects\\building-os-platform\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /persona/conversations?user_id=api-test-user (Caused by ResponseError('too many 500 error responses'))"}, "traceback": [{"path": "test_endpoints.py", "lineno": 101, "message": ""}, {"path": "client.py", "lineno": 119, "message": "in get"}, {"path": "client.py", "lineno": 64, "message": "in make_request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 589, "message": "in request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 703, "message": "in send"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "RetryError"}], "stdout": "\n\ud83d\ude80 GET /persona/conversations?user_id=api-test-user\n\u274c Request failed: \nHTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', \nport=443): Max retries exceeded with url: \n/persona/conversations?user_id=api-test-user (Caused by ResponseError('too many\n500 error responses'))\n", "longrepr": "urllib3.exceptions.ResponseError: too many 500 error responses\n\nThe above exception was the direct cause of the following exception:\n\nself = <requests.adapters.HTTPAdapter object at 0x00000241A55A51D0>, request = <PreparedRequest [GET]>, stream = False, timeout = Timeout(connect=30, read=30, total=None), verify = True, cert = None\nproxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n>           resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:486: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:932: in urlopen\n    retries = retries.increment(method, url, response=response, _pool=self)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None), method = 'GET', url = '/persona/conversations?user_id=api-test-user'\nresponse = <urllib3.response.HTTPResponse object at 0x00000241A6D95CF0>, error = None, _pool = <urllib3.connectionpool.HTTPSConnectionPool object at 0x00000241A6945FD0>, _stacktrace = None\n\n    def increment(\n        self,\n        method: str | None = None,\n        url: str | None = None,\n        response: BaseHTTPResponse | None = None,\n        error: Exception | None = None,\n        _pool: ConnectionPool | None = None,\n        _stacktrace: TracebackType | None = None,\n    ) -> Self:\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or method is None or not self._is_method_retryable(method):\n                raise reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            response_redirect_location = response.get_redirect_location()\n            if response_redirect_location:\n                redirect_location = response_redirect_location\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n            reason = error or ResponseError(cause)\n>           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\nE           urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /persona/conversations?user_id=api-test-user (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:519: MaxRetryError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <api.test_endpoints.TestPersonaEndpoint object at 0x00000241A557B100>\n\n    def test_persona_conversations(self):\n        \"\"\"Test persona conversations endpoint\"\"\"\n        user_id = config.test_user_id\n>       response, data = client.get(f\"/persona/conversations?user_id={user_id}\")\n\ntest_endpoints.py:101: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nclient.py:119: in get\n    return self.make_request(\"GET\", endpoint, **kwargs)\nclient.py:64: in make_request\n    response = self.session.request(\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:589: in request\n    resp = self.send(prep, **send_kwargs)\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:703: in send\n    r = adapter.send(request, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <requests.adapters.HTTPAdapter object at 0x00000241A55A51D0>, request = <PreparedRequest [GET]>, stream = False, timeout = Timeout(connect=30, read=30, total=None), verify = True, cert = None\nproxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n            resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n    \n        except (ProtocolError, OSError) as err:\n            raise ConnectionError(err, request=request)\n    \n        except MaxRetryError as e:\n            if isinstance(e.reason, ConnectTimeoutError):\n                # TODO: Remove this in 3.0.0: see #2811\n                if not isinstance(e.reason, NewConnectionError):\n                    raise ConnectTimeout(e, request=request)\n    \n            if isinstance(e.reason, ResponseError):\n>               raise RetryError(e, request=request)\nE               requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /persona/conversations?user_id=api-test-user (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:510: RetryError"}, "teardown": {"duration": 0.0010039000007964205, "outcome": "passed", "stdout": "\n"}}, {"nodeid": "test_endpoints.py::TestElevatorEndpoint::test_elevator_call_basic", "lineno": 109, "outcome": "failed", "keywords": ["test_elevator_call_basic", "TestElevatorEndpoint", "test_endpoints.py", "__init__.py", "api"], "setup": {"duration": 0.0006562999988091178, "outcome": "passed"}, "call": {"duration": 7.8560847000007925, "outcome": "failed", "crash": {"path": "C:\\Projects\\building-os-platform\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /elevator/call (Caused by ResponseError('too many 500 error responses'))"}, "traceback": [{"path": "test_endpoints.py", "lineno": 113, "message": ""}, {"path": "client.py", "lineno": 122, "message": "in post"}, {"path": "client.py", "lineno": 64, "message": "in make_request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 589, "message": "in request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 703, "message": "in send"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "RetryError"}], "stdout": "\n\ud83d\ude80 POST /elevator/call\n\u274c Request failed: \nHTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', \nport=443): Max retries exceeded with url: /elevator/call (Caused by \nResponseError('too many 500 error responses'))\n", "longrepr": "urllib3.exceptions.ResponseError: too many 500 error responses\n\nThe above exception was the direct cause of the following exception:\n\nself = <requests.adapters.HTTPAdapter object at 0x00000241A55A51D0>, request = <PreparedRequest [POST]>, stream = False, timeout = Timeout(connect=30, read=30, total=None), verify = True, cert = None\nproxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n>           resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:486: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:932: in urlopen\n    retries = retries.increment(method, url, response=response, _pool=self)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None), method = 'POST', url = '/elevator/call', response = <urllib3.response.HTTPResponse object at 0x00000241A6DC1180>, error = None\n_pool = <urllib3.connectionpool.HTTPSConnectionPool object at 0x00000241A6945FD0>, _stacktrace = None\n\n    def increment(\n        self,\n        method: str | None = None,\n        url: str | None = None,\n        response: BaseHTTPResponse | None = None,\n        error: Exception | None = None,\n        _pool: ConnectionPool | None = None,\n        _stacktrace: TracebackType | None = None,\n    ) -> Self:\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or method is None or not self._is_method_retryable(method):\n                raise reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            response_redirect_location = response.get_redirect_location()\n            if response_redirect_location:\n                redirect_location = response_redirect_location\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n            reason = error or ResponseError(cause)\n>           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\nE           urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /elevator/call (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:519: MaxRetryError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <api.test_endpoints.TestElevatorEndpoint object at 0x00000241A55A6AD0>\n\n    def test_elevator_call_basic(self):\n        \"\"\"Test basic elevator call\"\"\"\n        payload = TestPayloads.elevator_call()\n>       response, data = client.post(\"/elevator/call\", json=payload)\n\ntest_endpoints.py:113: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nclient.py:122: in post\n    return self.make_request(\"POST\", endpoint, **kwargs)\nclient.py:64: in make_request\n    response = self.session.request(\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:589: in request\n    resp = self.send(prep, **send_kwargs)\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:703: in send\n    r = adapter.send(request, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <requests.adapters.HTTPAdapter object at 0x00000241A55A51D0>, request = <PreparedRequest [POST]>, stream = False, timeout = Timeout(connect=30, read=30, total=None), verify = True, cert = None\nproxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n            resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n    \n        except (ProtocolError, OSError) as err:\n            raise ConnectionError(err, request=request)\n    \n        except MaxRetryError as e:\n            if isinstance(e.reason, ConnectTimeoutError):\n                # TODO: Remove this in 3.0.0: see #2811\n                if not isinstance(e.reason, NewConnectionError):\n                    raise ConnectTimeout(e, request=request)\n    \n            if isinstance(e.reason, ResponseError):\n>               raise RetryError(e, request=request)\nE               requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /elevator/call (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:510: RetryError"}, "teardown": {"duration": 0.0009850999995251186, "outcome": "passed", "stdout": "\n"}}, {"nodeid": "test_endpoints.py::TestElevatorEndpoint::test_elevator_missing_mission_id", "lineno": 120, "outcome": "failed", "keywords": ["test_elevator_missing_mission_id", "TestElevatorEndpoint", "test_endpoints.py", "__init__.py", "api"], "setup": {"duration": 0.0009581999984220602, "outcome": "passed"}, "call": {"duration": 6.7706603000006, "outcome": "failed", "crash": {"path": "C:\\Projects\\building-os-platform\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /elevator/call (Caused by ResponseError('too many 500 error responses'))"}, "traceback": [{"path": "test_endpoints.py", "lineno": 124, "message": ""}, {"path": "client.py", "lineno": 122, "message": "in post"}, {"path": "client.py", "lineno": 64, "message": "in make_request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 589, "message": "in request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 703, "message": "in send"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "RetryError"}], "stdout": "\n\ud83d\ude80 POST /elevator/call\n\u274c Request failed: \nHTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', \nport=443): Max retries exceeded with url: /elevator/call (Caused by \nResponseError('too many 500 error responses'))\n", "longrepr": "urllib3.exceptions.ResponseError: too many 500 error responses\n\nThe above exception was the direct cause of the following exception:\n\nself = <requests.adapters.HTTPAdapter object at 0x00000241A55A51D0>, request = <PreparedRequest [POST]>, stream = False, timeout = Timeout(connect=30, read=30, total=None), verify = True, cert = None\nproxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n>           resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:486: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:932: in urlopen\n    retries = retries.increment(method, url, response=response, _pool=self)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None), method = 'POST', url = '/elevator/call', response = <urllib3.response.HTTPResponse object at 0x00000241A6DC2AA0>, error = None\n_pool = <urllib3.connectionpool.HTTPSConnectionPool object at 0x00000241A6945FD0>, _stacktrace = None\n\n    def increment(\n        self,\n        method: str | None = None,\n        url: str | None = None,\n        response: BaseHTTPResponse | None = None,\n        error: Exception | None = None,\n        _pool: ConnectionPool | None = None,\n        _stacktrace: TracebackType | None = None,\n    ) -> Self:\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or method is None or not self._is_method_retryable(method):\n                raise reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            response_redirect_location = response.get_redirect_location()\n            if response_redirect_location:\n                redirect_location = response_redirect_location\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n            reason = error or ResponseError(cause)\n>           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\nE           urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /elevator/call (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:519: MaxRetryError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <api.test_endpoints.TestElevatorEndpoint object at 0x00000241A55A6C10>\n\n    def test_elevator_missing_mission_id(self):\n        \"\"\"Test elevator call without mission_id\"\"\"\n        payload = {\"action\": \"call_elevator\", \"parameters\": {\"floor\": 3}}\n>       response, data = client.post(\"/elevator/call\", json=payload)\n\ntest_endpoints.py:124: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nclient.py:122: in post\n    return self.make_request(\"POST\", endpoint, **kwargs)\nclient.py:64: in make_request\n    response = self.session.request(\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:589: in request\n    resp = self.send(prep, **send_kwargs)\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:703: in send\n    r = adapter.send(request, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <requests.adapters.HTTPAdapter object at 0x00000241A55A51D0>, request = <PreparedRequest [POST]>, stream = False, timeout = Timeout(connect=30, read=30, total=None), verify = True, cert = None\nproxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n            resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n    \n        except (ProtocolError, OSError) as err:\n            raise ConnectionError(err, request=request)\n    \n        except MaxRetryError as e:\n            if isinstance(e.reason, ConnectTimeoutError):\n                # TODO: Remove this in 3.0.0: see #2811\n                if not isinstance(e.reason, NewConnectionError):\n                    raise ConnectTimeout(e, request=request)\n    \n            if isinstance(e.reason, ResponseError):\n>               raise RetryError(e, request=request)\nE               requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /elevator/call (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:510: RetryError"}, "teardown": {"duration": 0.0010218999996141065, "outcome": "passed", "stdout": "\n"}}, {"nodeid": "test_endpoints.py::TestPSIMEndpoint::test_psim_search_basic", "lineno": 132, "outcome": "passed", "keywords": ["test_psim_search_basic", "TestPSIMEndpoint", "test_endpoints.py", "__init__.py", "api"], "setup": {"duration": 0.0008092999996733852, "outcome": "passed"}, "call": {"duration": 0.48310290000154055, "outcome": "passed", "stdout": "\n\ud83d\ude80 POST /psim/search\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 480.41ms | \ud83d\udce6 Size: 223 bytes\n"}, "teardown": {"duration": 0.0009632000001147389, "outcome": "passed", "stdout": "\n"}}, {"nodeid": "test_endpoints.py::TestPSIMEndpoint::test_psim_search_with_custom_query", "lineno": 142, "outcome": "passed", "keywords": ["test_psim_search_with_custom_query", "TestPSIMEndpoint", "test_endpoints.py", "__init__.py", "api"], "setup": {"duration": 0.0005249999994703103, "outcome": "passed"}, "call": {"duration": 0.3279438999998092, "outcome": "passed", "stdout": "\n\ud83d\ude80 POST /psim/search\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 325.71ms | \ud83d\udce6 Size: 223 bytes\n"}, "teardown": {"duration": 0.0008376000005227979, "outcome": "passed", "stdout": "\n"}}, {"nodeid": "test_endpoints.py::TestCoordinatorEndpoint::test_coordinator_mission_status", "lineno": 155, "outcome": "passed", "keywords": ["test_coordinator_mission_status", "TestCoordinatorEndpoint", "test_endpoints.py", "__init__.py", "api"], "setup": {"duration": 0.000543500002095243, "outcome": "passed"}, "call": {"duration": 0.20824939999874914, "outcome": "passed", "stdout": "\n\ud83d\ude80 GET /coordinator/missions/test-mission-123\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 205.56ms | \ud83d\udce6 Size: 463 bytes\n"}, "teardown": {"duration": 0.0009676000008767005, "outcome": "passed", "stdout": "\n"}}, {"nodeid": "test_endpoints.py::TestCoordinatorEndpoint::test_coordinator_different_mission_id", "lineno": 166, "outcome": "failed", "keywords": ["test_coordinator_different_mission_id", "TestCoordinatorEndpoint", "test_endpoints.py", "__init__.py", "api"], "setup": {"duration": 0.0005307999999786261, "outcome": "passed"}, "call": {"duration": 0.21836229999826173, "outcome": "failed", "crash": {"path": "c:\\Projects\\building-os-platform\\tests\\api\\test_endpoints.py", "lineno": 172, "message": "assert 404 == 200\n +  where 404 = <Response [404]>.status_code"}, "traceback": [{"path": "test_endpoints.py", "lineno": 172, "message": "AssertionError"}], "stdout": "\n\ud83d\ude80 GET /coordinator/missions/python-test-1754582824\n\ud83d\udcca Status: 404 | \u23f1\ufe0f  Time: 215.81ms | \ud83d\udce6 Size: 53 bytes\n", "longrepr": "self = <api.test_endpoints.TestCoordinatorEndpoint object at 0x00000241A55A7110>\n\n    def test_coordinator_different_mission_id(self):\n        \"\"\"Test coordinator with different mission ID\"\"\"\n        mission_id = f\"python-test-{int(time.time())}\"\n        response, data = client.get(f\"/coordinator/missions/{mission_id}\")\n    \n>       assert response.status_code == 200\nE       assert 404 == 200\nE        +  where 404 = <Response [404]>.status_code\n\ntest_endpoints.py:172: AssertionError"}, "teardown": {"duration": 0.0009682999989308883, "outcome": "passed", "stdout": "\n"}}, {"nodeid": "test_endpoints.py::TestCORSHeaders::test_cors_headers_present[/health]", "lineno": 178, "outcome": "failed", "keywords": ["test_cors_headers_present[/health]", "parametrize", "pytestmark", "/health", "TestCORSHeaders", "test_endpoints.py", "__init__.py", "api"], "setup": {"duration": 0.000687899999320507, "outcome": "passed"}, "call": {"duration": 0.2019564000001992, "outcome": "failed", "crash": {"path": "c:\\Projects\\building-os-platform\\tests\\api\\test_endpoints.py", "lineno": 215, "message": "AssertionError: No CORS headers found in response for /health\nassert False"}, "traceback": [{"path": "test_endpoints.py", "lineno": 215, "message": "AssertionError"}], "stdout": "\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 199.67ms | \ud83d\udce6 Size: 60 bytes\n", "longrepr": "self = <api.test_endpoints.TestCORSHeaders object at 0x00000241A55A74D0>, endpoint = '/health'\n\n    @pytest.mark.parametrize(\n        \"endpoint\",\n        [\n            \"/health\",\n            \"/director\",\n            \"/persona\",\n            \"/elevator/call\",\n            \"/psim/search\",\n            \"/coordinator/missions/test-123\",\n        ],\n    )\n    def test_cors_headers_present(self, endpoint):\n        \"\"\"Test that CORS headers are present\"\"\"\n        method = (\n            \"POST\"\n            if endpoint in [\"/persona\", \"/elevator/call\", \"/psim/search\"]\n            else \"GET\"\n        )\n    \n        if method == \"POST\":\n            payload = {\"test\": \"data\"}\n            response, _ = client.post(endpoint, json=payload)\n        else:\n            response, _ = client.get(endpoint)\n    \n        # Check for CORS headers (they might be case-insensitive)\n        headers_lower = {k.lower(): v for k, v in response.headers.items()}\n    \n        # At least one CORS header should be present\n        cors_headers = [\n            \"access-control-allow-origin\",\n            \"access-control-allow-methods\",\n            \"access-control-allow-headers\",\n        ]\n    \n        has_cors = any(header in headers_lower for header in cors_headers)\n>       assert has_cors, f\"No CORS headers found in response for {endpoint}\"\nE       AssertionError: No CORS headers found in response for /health\nE       assert False\n\ntest_endpoints.py:215: AssertionError"}, "teardown": {"duration": 0.0009024999999382999, "outcome": "passed", "stdout": "\n"}}, {"nodeid": "test_endpoints.py::TestCORSHeaders::test_cors_headers_present[/director]", "lineno": 178, "outcome": "failed", "keywords": ["test_cors_headers_present[/director]", "parametrize", "pytestmark", "/director", "TestCORSHeaders", "test_endpoints.py", "__init__.py", "api"], "setup": {"duration": 0.0005726000017602928, "outcome": "passed"}, "call": {"duration": 3.255096799999592, "outcome": "failed", "crash": {"path": "c:\\Projects\\building-os-platform\\tests\\api\\test_endpoints.py", "lineno": 215, "message": "AssertionError: No CORS headers found in response for /director\nassert False"}, "traceback": [{"path": "test_endpoints.py", "lineno": 215, "message": "AssertionError"}], "stdout": "\n\ud83d\ude80 GET /director\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 3252.68ms | \ud83d\udce6 Size: 128 bytes\n", "longrepr": "self = <api.test_endpoints.TestCORSHeaders object at 0x00000241A55A7610>, endpoint = '/director'\n\n    @pytest.mark.parametrize(\n        \"endpoint\",\n        [\n            \"/health\",\n            \"/director\",\n            \"/persona\",\n            \"/elevator/call\",\n            \"/psim/search\",\n            \"/coordinator/missions/test-123\",\n        ],\n    )\n    def test_cors_headers_present(self, endpoint):\n        \"\"\"Test that CORS headers are present\"\"\"\n        method = (\n            \"POST\"\n            if endpoint in [\"/persona\", \"/elevator/call\", \"/psim/search\"]\n            else \"GET\"\n        )\n    \n        if method == \"POST\":\n            payload = {\"test\": \"data\"}\n            response, _ = client.post(endpoint, json=payload)\n        else:\n            response, _ = client.get(endpoint)\n    \n        # Check for CORS headers (they might be case-insensitive)\n        headers_lower = {k.lower(): v for k, v in response.headers.items()}\n    \n        # At least one CORS header should be present\n        cors_headers = [\n            \"access-control-allow-origin\",\n            \"access-control-allow-methods\",\n            \"access-control-allow-headers\",\n        ]\n    \n        has_cors = any(header in headers_lower for header in cors_headers)\n>       assert has_cors, f\"No CORS headers found in response for {endpoint}\"\nE       AssertionError: No CORS headers found in response for /director\nE       assert False\n\ntest_endpoints.py:215: AssertionError"}, "teardown": {"duration": 0.0009078999974008184, "outcome": "passed", "stdout": "\n"}}, {"nodeid": "test_endpoints.py::TestCORSHeaders::test_cors_headers_present[/persona]", "lineno": 178, "outcome": "failed", "keywords": ["test_cors_headers_present[/persona]", "parametrize", "pytestmark", "/persona", "TestCORSHeaders", "test_endpoints.py", "__init__.py", "api"], "setup": {"duration": 0.0005830000009154901, "outcome": "passed"}, "call": {"duration": 0.20918710000114515, "outcome": "failed", "crash": {"path": "c:\\Projects\\building-os-platform\\tests\\api\\test_endpoints.py", "lineno": 215, "message": "AssertionError: No CORS headers found in response for /persona\nassert False"}, "traceback": [{"path": "test_endpoints.py", "lineno": 215, "message": "AssertionError"}], "stdout": "\n\ud83d\ude80 POST /persona\n\ud83d\udcca Status: 400 | \u23f1\ufe0f  Time: 206.84ms | \ud83d\udce6 Size: 45 bytes\n", "longrepr": "self = <api.test_endpoints.TestCORSHeaders object at 0x00000241A557B5C0>, endpoint = '/persona'\n\n    @pytest.mark.parametrize(\n        \"endpoint\",\n        [\n            \"/health\",\n            \"/director\",\n            \"/persona\",\n            \"/elevator/call\",\n            \"/psim/search\",\n            \"/coordinator/missions/test-123\",\n        ],\n    )\n    def test_cors_headers_present(self, endpoint):\n        \"\"\"Test that CORS headers are present\"\"\"\n        method = (\n            \"POST\"\n            if endpoint in [\"/persona\", \"/elevator/call\", \"/psim/search\"]\n            else \"GET\"\n        )\n    \n        if method == \"POST\":\n            payload = {\"test\": \"data\"}\n            response, _ = client.post(endpoint, json=payload)\n        else:\n            response, _ = client.get(endpoint)\n    \n        # Check for CORS headers (they might be case-insensitive)\n        headers_lower = {k.lower(): v for k, v in response.headers.items()}\n    \n        # At least one CORS header should be present\n        cors_headers = [\n            \"access-control-allow-origin\",\n            \"access-control-allow-methods\",\n            \"access-control-allow-headers\",\n        ]\n    \n        has_cors = any(header in headers_lower for header in cors_headers)\n>       assert has_cors, f\"No CORS headers found in response for {endpoint}\"\nE       AssertionError: No CORS headers found in response for /persona\nE       assert False\n\ntest_endpoints.py:215: AssertionError"}, "teardown": {"duration": 0.0008841999988362659, "outcome": "passed", "stdout": "\n"}}, {"nodeid": "test_endpoints.py::TestCORSHeaders::test_cors_headers_present[/elevator/call]", "lineno": 178, "outcome": "failed", "keywords": ["test_cors_headers_present[/elevator/call]", "parametrize", "pytestmark", "/elevator/call", "TestCORSHeaders", "test_endpoints.py", "__init__.py", "api"], "setup": {"duration": 0.0005479000028572045, "outcome": "passed"}, "call": {"duration": 6.843532200000482, "outcome": "failed", "crash": {"path": "C:\\Projects\\building-os-platform\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /elevator/call (Caused by ResponseError('too many 500 error responses'))"}, "traceback": [{"path": "test_endpoints.py", "lineno": 200, "message": ""}, {"path": "client.py", "lineno": 122, "message": "in post"}, {"path": "client.py", "lineno": 64, "message": "in make_request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 589, "message": "in request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 703, "message": "in send"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "RetryError"}], "stdout": "\n\ud83d\ude80 POST /elevator/call\n\u274c Request failed: \nHTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', \nport=443): Max retries exceeded with url: /elevator/call (Caused by \nResponseError('too many 500 error responses'))\n", "longrepr": "urllib3.exceptions.ResponseError: too many 500 error responses\n\nThe above exception was the direct cause of the following exception:\n\nself = <requests.adapters.HTTPAdapter object at 0x00000241A55A51D0>, request = <PreparedRequest [POST]>, stream = False, timeout = Timeout(connect=30, read=30, total=None)\nverify = True, cert = None, proxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n>           resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:486: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:932: in urlopen\n    retries = retries.increment(method, url, response=response, _pool=self)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None), method = 'POST', url = '/elevator/call'\nresponse = <urllib3.response.HTTPResponse object at 0x00000241A6E58640>, error = None, _pool = <urllib3.connectionpool.HTTPSConnectionPool object at 0x00000241A6945FD0>\n_stacktrace = None\n\n    def increment(\n        self,\n        method: str | None = None,\n        url: str | None = None,\n        response: BaseHTTPResponse | None = None,\n        error: Exception | None = None,\n        _pool: ConnectionPool | None = None,\n        _stacktrace: TracebackType | None = None,\n    ) -> Self:\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or method is None or not self._is_method_retryable(method):\n                raise reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            response_redirect_location = response.get_redirect_location()\n            if response_redirect_location:\n                redirect_location = response_redirect_location\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n            reason = error or ResponseError(cause)\n>           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\nE           urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /elevator/call (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:519: MaxRetryError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <api.test_endpoints.TestCORSHeaders object at 0x00000241A557B6F0>, endpoint = '/elevator/call'\n\n    @pytest.mark.parametrize(\n        \"endpoint\",\n        [\n            \"/health\",\n            \"/director\",\n            \"/persona\",\n            \"/elevator/call\",\n            \"/psim/search\",\n            \"/coordinator/missions/test-123\",\n        ],\n    )\n    def test_cors_headers_present(self, endpoint):\n        \"\"\"Test that CORS headers are present\"\"\"\n        method = (\n            \"POST\"\n            if endpoint in [\"/persona\", \"/elevator/call\", \"/psim/search\"]\n            else \"GET\"\n        )\n    \n        if method == \"POST\":\n            payload = {\"test\": \"data\"}\n>           response, _ = client.post(endpoint, json=payload)\n\ntest_endpoints.py:200: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nclient.py:122: in post\n    return self.make_request(\"POST\", endpoint, **kwargs)\nclient.py:64: in make_request\n    response = self.session.request(\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:589: in request\n    resp = self.send(prep, **send_kwargs)\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:703: in send\n    r = adapter.send(request, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <requests.adapters.HTTPAdapter object at 0x00000241A55A51D0>, request = <PreparedRequest [POST]>, stream = False, timeout = Timeout(connect=30, read=30, total=None)\nverify = True, cert = None, proxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n            resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n    \n        except (ProtocolError, OSError) as err:\n            raise ConnectionError(err, request=request)\n    \n        except MaxRetryError as e:\n            if isinstance(e.reason, ConnectTimeoutError):\n                # TODO: Remove this in 3.0.0: see #2811\n                if not isinstance(e.reason, NewConnectionError):\n                    raise ConnectTimeout(e, request=request)\n    \n            if isinstance(e.reason, ResponseError):\n>               raise RetryError(e, request=request)\nE               requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /elevator/call (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:510: RetryError"}, "teardown": {"duration": 0.0009678999995230697, "outcome": "passed", "stdout": "\n"}}, {"nodeid": "test_endpoints.py::TestCORSHeaders::test_cors_headers_present[/psim/search]", "lineno": 178, "outcome": "failed", "keywords": ["test_cors_headers_present[/psim/search]", "parametrize", "pytestmark", "/psim/search", "TestCORSHeaders", "test_endpoints.py", "__init__.py", "api"], "setup": {"duration": 0.000616100001934683, "outcome": "passed"}, "call": {"duration": 0.32923740000114776, "outcome": "failed", "crash": {"path": "c:\\Projects\\building-os-platform\\tests\\api\\test_endpoints.py", "lineno": 215, "message": "AssertionError: No CORS headers found in response for /psim/search\nassert False"}, "traceback": [{"path": "test_endpoints.py", "lineno": 215, "message": "AssertionError"}], "stdout": "\n\ud83d\ude80 POST /psim/search\n\ud83d\udcca Status: 400 | \u23f1\ufe0f  Time: 326.45ms | \ud83d\udce6 Size: 43 bytes\n", "longrepr": "self = <api.test_endpoints.TestCORSHeaders object at 0x00000241A56605F0>, endpoint = '/psim/search'\n\n    @pytest.mark.parametrize(\n        \"endpoint\",\n        [\n            \"/health\",\n            \"/director\",\n            \"/persona\",\n            \"/elevator/call\",\n            \"/psim/search\",\n            \"/coordinator/missions/test-123\",\n        ],\n    )\n    def test_cors_headers_present(self, endpoint):\n        \"\"\"Test that CORS headers are present\"\"\"\n        method = (\n            \"POST\"\n            if endpoint in [\"/persona\", \"/elevator/call\", \"/psim/search\"]\n            else \"GET\"\n        )\n    \n        if method == \"POST\":\n            payload = {\"test\": \"data\"}\n            response, _ = client.post(endpoint, json=payload)\n        else:\n            response, _ = client.get(endpoint)\n    \n        # Check for CORS headers (they might be case-insensitive)\n        headers_lower = {k.lower(): v for k, v in response.headers.items()}\n    \n        # At least one CORS header should be present\n        cors_headers = [\n            \"access-control-allow-origin\",\n            \"access-control-allow-methods\",\n            \"access-control-allow-headers\",\n        ]\n    \n        has_cors = any(header in headers_lower for header in cors_headers)\n>       assert has_cors, f\"No CORS headers found in response for {endpoint}\"\nE       AssertionError: No CORS headers found in response for /psim/search\nE       assert False\n\ntest_endpoints.py:215: AssertionError"}, "teardown": {"duration": 0.0010110000002896413, "outcome": "passed", "stdout": "\n"}}, {"nodeid": "test_endpoints.py::TestCORSHeaders::test_cors_headers_present[/coordinator/missions/test-123]", "lineno": 178, "outcome": "failed", "keywords": ["test_cors_headers_present[/coordinator/missions/test-123]", "parametrize", "pytestmark", "/coordinator/missions/test-123", "TestCORSHeaders", "test_endpoints.py", "__init__.py", "api"], "setup": {"duration": 0.0007721000001765788, "outcome": "passed"}, "call": {"duration": 0.20589280000058352, "outcome": "failed", "crash": {"path": "c:\\Projects\\building-os-platform\\tests\\api\\test_endpoints.py", "lineno": 215, "message": "AssertionError: No CORS headers found in response for /coordinator/missions/test-123\nassert False"}, "traceback": [{"path": "test_endpoints.py", "lineno": 215, "message": "AssertionError"}], "stdout": "\n\ud83d\ude80 GET /coordinator/missions/test-123\n\ud83d\udcca Status: 404 | \u23f1\ufe0f  Time: 203.58ms | \ud83d\udce6 Size: 39 bytes\n", "longrepr": "self = <api.test_endpoints.TestCORSHeaders object at 0x00000241A560CC00>, endpoint = '/coordinator/missions/test-123'\n\n    @pytest.mark.parametrize(\n        \"endpoint\",\n        [\n            \"/health\",\n            \"/director\",\n            \"/persona\",\n            \"/elevator/call\",\n            \"/psim/search\",\n            \"/coordinator/missions/test-123\",\n        ],\n    )\n    def test_cors_headers_present(self, endpoint):\n        \"\"\"Test that CORS headers are present\"\"\"\n        method = (\n            \"POST\"\n            if endpoint in [\"/persona\", \"/elevator/call\", \"/psim/search\"]\n            else \"GET\"\n        )\n    \n        if method == \"POST\":\n            payload = {\"test\": \"data\"}\n            response, _ = client.post(endpoint, json=payload)\n        else:\n            response, _ = client.get(endpoint)\n    \n        # Check for CORS headers (they might be case-insensitive)\n        headers_lower = {k.lower(): v for k, v in response.headers.items()}\n    \n        # At least one CORS header should be present\n        cors_headers = [\n            \"access-control-allow-origin\",\n            \"access-control-allow-methods\",\n            \"access-control-allow-headers\",\n        ]\n    \n        has_cors = any(header in headers_lower for header in cors_headers)\n>       assert has_cors, f\"No CORS headers found in response for {endpoint}\"\nE       AssertionError: No CORS headers found in response for /coordinator/missions/test-123\nE       assert False\n\ntest_endpoints.py:215: AssertionError"}, "teardown": {"duration": 0.0008773999979894143, "outcome": "passed", "stdout": "\n"}}, {"nodeid": "test_endpoints.py::TestErrorHandling::test_invalid_endpoint", "lineno": 220, "outcome": "passed", "keywords": ["test_invalid_endpoint", "TestErrorHandling", "test_endpoints.py", "__init__.py", "api"], "setup": {"duration": 0.0004439000003912952, "outcome": "passed"}, "call": {"duration": 0.1681581000011647, "outcome": "passed", "stdout": "\n\ud83d\ude80 GET /invalid-endpoint\n\ud83d\udcca Status: 404 | \u23f1\ufe0f  Time: 166.04ms | \ud83d\udce6 Size: 23 bytes\n"}, "teardown": {"duration": 0.000703800000337651, "outcome": "passed", "stdout": "\n"}}, {"nodeid": "test_endpoints.py::TestErrorHandling::test_invalid_method", "lineno": 225, "outcome": "passed", "keywords": ["test_invalid_method", "TestErrorHandling", "test_endpoints.py", "__init__.py", "api"], "setup": {"duration": 0.0010645000002114102, "outcome": "passed"}, "call": {"duration": 0.1769819999972242, "outcome": "passed", "stdout": "\n\ud83d\ude80 DELETE /health\n\ud83d\udcca Status: 404 | \u23f1\ufe0f  Time: 174.76ms | \ud83d\udce6 Size: 23 bytes\n"}, "teardown": {"duration": 0.0007646000012755394, "outcome": "passed", "stdout": "\n"}}, {"nodeid": "test_endpoints.py::TestErrorHandling::test_malformed_json", "lineno": 235, "outcome": "passed", "keywords": ["test_malformed_json", "TestErrorHandling", "test_endpoints.py", "__init__.py", "api"], "setup": {"duration": 0.0005473999990499578, "outcome": "passed"}, "call": {"duration": 6.800525099999504, "outcome": "passed"}, "teardown": {"duration": 0.0009973000014724676, "outcome": "passed", "stdout": "\n"}}, {"nodeid": "test_performance.py::TestPerformance::test_response_time_under_threshold", "lineno": 18, "outcome": "failed", "keywords": ["test_response_time_under_threshold", "TestPerformance", "test_performance.py", "__init__.py", "api"], "setup": {"duration": 0.00046920000022510067, "outcome": "passed"}, "call": {"duration": 15.862115500000073, "outcome": "failed", "crash": {"path": "c:\\Projects\\building-os-platform\\tests\\api\\test_performance.py", "lineno": 42, "message": "AssertionError: /director took 15670.95ms (threshold: 3000ms)\nassert 15670.952320098877 < 3000"}, "traceback": [{"path": "test_performance.py", "lineno": 42, "message": "AssertionError"}], "stdout": "\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 188.40ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /director\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 15669.36ms | \ud83d\udce6 Size: 128 bytes\n", "longrepr": "self = <api.test_performance.TestPerformance object at 0x00000241A6DBC050>\n\n    def test_response_time_under_threshold(self):\n        \"\"\"Test that all endpoints respond within acceptable time\"\"\"\n        endpoints = [\n            (\"/health\", \"GET\", None),\n            (\"/director\", \"GET\", None),\n            (\"/persona\", \"POST\", {\"user_id\": \"perf-test\", \"message\": \"test\"}),\n            (\"/psim/search\", \"POST\", {\"action\": \"search_person\", \"query\": \"test\"}),\n            (\"/coordinator/missions/perf-test-123\", \"GET\", None),\n        ]\n    \n        threshold_ms = 3000  # 3 seconds\n    \n        for endpoint, method, payload in endpoints:\n            start_time = time.time()\n    \n            if method == \"GET\":\n                response, data = client.get(endpoint)\n            else:\n                response, data = client.post(endpoint, json=payload)\n    \n            end_time = time.time()\n            response_time = (end_time - start_time) * 1000\n    \n>           assert (\n                response_time < threshold_ms\n            ), f\"{endpoint} took {response_time:.2f}ms (threshold: {threshold_ms}ms)\"\nE           AssertionError: /director took 15670.95ms (threshold: 3000ms)\nE           assert 15670.952320098877 < 3000\n\ntest_performance.py:42: AssertionError"}, "teardown": {"duration": 0.00045759999920846894, "outcome": "passed"}}, {"nodeid": "test_performance.py::TestPerformance::test_concurrent_health_checks", "lineno": 45, "outcome": "passed", "keywords": ["test_concurrent_health_checks", "TestPerformance", "test_performance.py", "__init__.py", "api"], "setup": {"duration": 0.0003899000003002584, "outcome": "passed"}, "call": {"duration": 1.8192311000020709, "outcome": "passed", "stdout": "\n\ud83d\ude80 GET /health\n\n\ud83d\ude80 GET /health\n\n\ud83d\ude80 GET /health\n\n\ud83d\ude80 GET /health\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 237.43ms | \ud83d\udce6 Size: 60 bytes\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 1713.34ms | \ud83d\udce6 Size: 60 bytes\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 1787.76ms | \ud83d\udce6 Size: 60 bytes\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 1796.69ms | \ud83d\udce6 Size: 60 bytes\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 1807.62ms | \ud83d\udce6 Size: 60 bytes\n"}, "teardown": {"duration": 0.0004344000008131843, "outcome": "passed"}}, {"nodeid": "test_performance.py::TestLoadTesting::test_sustained_load_health_endpoint", "lineno": 72, "outcome": "passed", "keywords": ["test_sustained_load_health_endpoint", "slow", "pytestmark", "TestLoadTesting", "test_performance.py", "__init__.py", "api"], "setup": {"duration": 0.0004608999988704454, "outcome": "passed"}, "call": {"duration": 14.93313599999965, "outcome": "passed", "stdout": "\n\ud83d\udd25 Running sustained load test...\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 179.07ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 182.53ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 184.97ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 176.89ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 173.49ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 178.16ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 175.38ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 176.05ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 190.57ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 333.85ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 176.79ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 183.11ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 184.70ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 209.02ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 192.60ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 184.58ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 1718.37ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 201.94ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 189.56ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 176.57ms | \ud83d\udce6 Size: 60 bytes\n  Making 20 requests... 0:00:14\n\u2705 Success rate: 100.0% (20/20)\n\u23f1\ufe0f  Avg response: 270.51ms\n\ud83d\udc0c Max response: 1720.12ms\n\u26a1 Min response: 175.20ms\n"}, "teardown": {"duration": 0.0005466000002343208, "outcome": "passed"}}, {"nodeid": "test_performance.py::TestStressScenarios::test_large_payload_persona", "lineno": 149, "outcome": "failed", "keywords": ["test_large_payload_persona", "TestStressScenarios", "test_performance.py", "__init__.py", "api"], "setup": {"duration": 0.0005218000005697832, "outcome": "passed"}, "call": {"duration": 0.9827413999992132, "outcome": "failed", "crash": {"path": "c:\\Projects\\building-os-platform\\tests\\api\\test_performance.py", "lineno": 158, "message": "assert 202 in [200, 413, 400]\n +  where 202 = <Response [202]>.status_code"}, "traceback": [{"path": "test_performance.py", "lineno": 158, "message": "AssertionError"}], "stdout": "\n\ud83d\ude80 POST /persona\n\ud83d\udcca Status: 202 | \u23f1\ufe0f  Time: 979.62ms | \ud83d\udce6 Size: 135 bytes\n", "longrepr": "self = <api.test_performance.TestStressScenarios object at 0x00000241A6DBC410>\n\n    def test_large_payload_persona(self):\n        \"\"\"Test persona endpoint with large message\"\"\"\n        large_message = \"x\" * 10000  # 10KB message\n        payload = {\"user_id\": \"stress-test-user\", \"message\": large_message}\n    \n        response, data = client.post(\"/persona\", json=payload)\n    \n        # Should handle large payloads gracefully\n>       assert response.status_code in [\n            200,\n            413,\n            400,\n        ]  # Success, Payload Too Large, or Bad Request\nE       assert 202 in [200, 413, 400]\nE        +  where 202 = <Response [202]>.status_code\n\ntest_performance.py:158: AssertionError"}, "teardown": {"duration": 0.0004439000003912952, "outcome": "passed"}}, {"nodeid": "test_performance.py::TestStressScenarios::test_rapid_successive_requests", "lineno": 163, "outcome": "passed", "keywords": ["test_rapid_successive_requests", "TestStressScenarios", "test_performance.py", "__init__.py", "api"], "setup": {"duration": 0.00040490000174031593, "outcome": "passed"}, "call": {"duration": 1.870210600001883, "outcome": "passed", "stdout": "\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 172.60ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 175.33ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 220.04ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 186.43ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 185.31ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 186.49ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 182.81ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 184.28ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 182.78ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 178.05ms | \ud83d\udce6 Size: 60 bytes\n\ud83d\ude80 Rapid requests: 10 in 1.87s\n\u2705 Success rate: 100.0%\n"}, "teardown": {"duration": 0.00043169999844394624, "outcome": "passed"}}, {"nodeid": "test_performance.py::TestStressScenarios::test_special_characters_in_requests", "lineno": 189, "outcome": "passed", "keywords": ["test_special_characters_in_requests", "TestStressScenarios", "test_performance.py", "__init__.py", "api"], "setup": {"duration": 0.0003479000006336719, "outcome": "passed"}, "call": {"duration": 1.0972020999979577, "outcome": "passed", "stdout": "\n\ud83d\ude80 POST /persona\n\ud83d\udcca Status: 202 | \u23f1\ufe0f  Time: 632.29ms | \ud83d\udce6 Size: 135 bytes\n\n\ud83d\ude80 POST /persona\n\ud83d\udcca Status: 202 | \u23f1\ufe0f  Time: 217.17ms | \ud83d\udce6 Size: 135 bytes\n\n\ud83d\ude80 POST /persona\n\ud83d\udcca Status: 202 | \u23f1\ufe0f  Time: 242.75ms | \ud83d\udce6 Size: 135 bytes\n"}, "teardown": {"duration": 0.0003541999976732768, "outcome": "passed"}}, {"nodeid": "test_performance.py::TestBoundaryConditions::test_empty_payloads", "lineno": 213, "outcome": "failed", "keywords": ["test_empty_payloads", "TestBoundaryConditions", "test_performance.py", "__init__.py", "api"], "setup": {"duration": 0.0004291000004741363, "outcome": "passed"}, "call": {"duration": 6.932057599999098, "outcome": "failed", "crash": {"path": "C:\\Projects\\building-os-platform\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /elevator/call (Caused by ResponseError('too many 500 error responses'))"}, "traceback": [{"path": "test_performance.py", "lineno": 219, "message": ""}, {"path": "client.py", "lineno": 122, "message": "in post"}, {"path": "client.py", "lineno": 64, "message": "in make_request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 589, "message": "in request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 703, "message": "in send"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "RetryError"}], "stdout": "\n\ud83d\ude80 POST /persona\n\ud83d\udcca Status: 400 | \u23f1\ufe0f  Time: 179.85ms | \ud83d\udce6 Size: 45 bytes\n\n\ud83d\ude80 POST /elevator/call\n\u274c Request failed: \nHTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', \nport=443): Max retries exceeded with url: /elevator/call (Caused by \nResponseError('too many 500 error responses'))\n", "longrepr": "urllib3.exceptions.ResponseError: too many 500 error responses\n\nThe above exception was the direct cause of the following exception:\n\nself = <requests.adapters.HTTPAdapter object at 0x00000241A55A51D0>, request = <PreparedRequest [POST]>, stream = False, timeout = Timeout(connect=30, read=30, total=None)\nverify = True, cert = None, proxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n>           resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:486: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:932: in urlopen\n    retries = retries.increment(method, url, response=response, _pool=self)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None), method = 'POST', url = '/elevator/call'\nresponse = <urllib3.response.HTTPResponse object at 0x00000241A6E50310>, error = None, _pool = <urllib3.connectionpool.HTTPSConnectionPool object at 0x00000241A6945FD0>\n_stacktrace = None\n\n    def increment(\n        self,\n        method: str | None = None,\n        url: str | None = None,\n        response: BaseHTTPResponse | None = None,\n        error: Exception | None = None,\n        _pool: ConnectionPool | None = None,\n        _stacktrace: TracebackType | None = None,\n    ) -> Self:\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or method is None or not self._is_method_retryable(method):\n                raise reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            response_redirect_location = response.get_redirect_location()\n            if response_redirect_location:\n                redirect_location = response_redirect_location\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n            reason = error or ResponseError(cause)\n>           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\nE           urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /elevator/call (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:519: MaxRetryError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <api.test_performance.TestBoundaryConditions object at 0x00000241A6DBC690>\n\n    def test_empty_payloads(self):\n        \"\"\"Test endpoints with empty payloads\"\"\"\n        endpoints_requiring_payload = [\"/persona\", \"/elevator/call\", \"/psim/search\"]\n    \n        for endpoint in endpoints_requiring_payload:\n>           response, data = client.post(endpoint, json={})\n\ntest_performance.py:219: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nclient.py:122: in post\n    return self.make_request(\"POST\", endpoint, **kwargs)\nclient.py:64: in make_request\n    response = self.session.request(\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:589: in request\n    resp = self.send(prep, **send_kwargs)\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:703: in send\n    r = adapter.send(request, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <requests.adapters.HTTPAdapter object at 0x00000241A55A51D0>, request = <PreparedRequest [POST]>, stream = False, timeout = Timeout(connect=30, read=30, total=None)\nverify = True, cert = None, proxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n            resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n    \n        except (ProtocolError, OSError) as err:\n            raise ConnectionError(err, request=request)\n    \n        except MaxRetryError as e:\n            if isinstance(e.reason, ConnectTimeoutError):\n                # TODO: Remove this in 3.0.0: see #2811\n                if not isinstance(e.reason, NewConnectionError):\n                    raise ConnectTimeout(e, request=request)\n    \n            if isinstance(e.reason, ResponseError):\n>               raise RetryError(e, request=request)\nE               requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /elevator/call (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:510: RetryError"}, "teardown": {"duration": 0.0005424000009952579, "outcome": "passed"}}, {"nodeid": "test_performance.py::TestBoundaryConditions::test_null_values_in_payload", "lineno": 224, "outcome": "passed", "keywords": ["test_null_values_in_payload", "TestBoundaryConditions", "test_performance.py", "__init__.py", "api"], "setup": {"duration": 0.0008951000017987099, "outcome": "passed"}, "call": {"duration": 0.18346590000146534, "outcome": "passed", "stdout": "\n\ud83d\ude80 POST /persona\n\ud83d\udcca Status: 400 | \u23f1\ufe0f  Time: 181.15ms | \ud83d\udce6 Size: 45 bytes\n"}, "teardown": {"duration": 0.0004182999982731417, "outcome": "passed"}}, {"nodeid": "test_performance.py::TestBoundaryConditions::test_extremely_long_mission_id", "lineno": 233, "outcome": "passed", "keywords": ["test_extremely_long_mission_id", "TestBoundaryConditions", "test_performance.py", "__init__.py", "api"], "setup": {"duration": 0.0004124000006413553, "outcome": "passed"}, "call": {"duration": 0.19407390000196756, "outcome": "passed", "stdout": "\n\ud83d\ude80 GET \n/coordinator/missions/xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n\ud83d\udcca Status: 404 | \u23f1\ufe0f  Time: 188.92ms | \ud83d\udce6 Size: 1031 bytes\n"}, "teardown": {"duration": 0.09041299999807961, "outcome": "passed", "stdout": "\n\ud83d\udcca Test Session Complete\n                              \ud83d\udd0d Request Summary                               \n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Method \u2502 Endpoint                            \u2502 Status \u2502 Time (ms) \u2502 Success \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 2536.7    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 196.97    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /director                           \u2502 200    \u2502 4472.8    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /director?user_request=Test mission \u2502 200    \u2502 6550.35   \u2502 \u2705      \u2502\n\u2502        \u2502 from Python API tests               \u2502        \u2502           \u2502         \u2502\n\u2502 GET    \u2502 /director?user_id=api-test-user     \u2502 200    \u2502 4704.11   \u2502 \u2705      \u2502\n\u2502 POST   \u2502 /persona                            \u2502 202    \u2502 468.62    \u2502 \u2705      \u2502\n\u2502 POST   \u2502 /persona                            \u2502 400    \u2502 198.11    \u2502 \u274c      \u2502\n\u2502 POST   \u2502 /persona                            \u2502 400    \u2502 197.93    \u2502 \u274c      \u2502\n\u2502 GET    \u2502 /persona/conversations?user_id=api\u2026 \u2502 0      \u2502 6945.8    \u2502 \u274c      \u2502\n\u2502 POST   \u2502 /elevator/call                      \u2502 0      \u2502 7853.34   \u2502 \u274c      \u2502\n\u2502 POST   \u2502 /elevator/call                      \u2502 0      \u2502 6767.69   \u2502 \u274c      \u2502\n\u2502 POST   \u2502 /psim/search                        \u2502 200    \u2502 480.41    \u2502 \u2705      \u2502\n\u2502 POST   \u2502 /psim/search                        \u2502 200    \u2502 325.71    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /coordinator/missions/test-mission\u2026 \u2502 200    \u2502 205.56    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /coordinator/missions/python-test-\u2026 \u2502 404    \u2502 215.81    \u2502 \u274c      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 199.67    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /director                           \u2502 200    \u2502 3252.68   \u2502 \u2705      \u2502\n\u2502 POST   \u2502 /persona                            \u2502 400    \u2502 206.84    \u2502 \u274c      \u2502\n\u2502 POST   \u2502 /elevator/call                      \u2502 0      \u2502 6840.98   \u2502 \u274c      \u2502\n\u2502 POST   \u2502 /psim/search                        \u2502 400    \u2502 326.45    \u2502 \u274c      \u2502\n\u2502 GET    \u2502 /coordinator/missions/test-123      \u2502 404    \u2502 203.58    \u2502 \u274c      \u2502\n\u2502 GET    \u2502 /invalid-endpoint                   \u2502 404    \u2502 166.04    \u2502 \u274c      \u2502\n\u2502 DELETE \u2502 /health                             \u2502 404    \u2502 174.76    \u2502 \u274c      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 188.4     \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /director                           \u2502 200    \u2502 15669.36  \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 237.43    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 1713.34   \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 1787.76   \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 1796.69   \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 1807.62   \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 179.07    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 182.53    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 184.97    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 176.89    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 173.49    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 178.16    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 175.38    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 176.05    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 190.57    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 333.85    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 176.79    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 183.11    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 184.7     \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 209.02    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 192.6     \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 184.58    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 1718.37   \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 201.94    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 189.56    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 176.57    \u2502 \u2705      \u2502\n\u2502 POST   \u2502 /persona                            \u2502 202    \u2502 979.62    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 172.6     \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 175.33    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 220.04    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 186.43    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 185.31    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 186.49    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 182.81    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 184.28    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 182.78    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 178.05    \u2502 \u2705      \u2502\n\u2502 POST   \u2502 /persona                            \u2502 202    \u2502 632.29    \u2502 \u2705      \u2502\n\u2502 POST   \u2502 /persona                            \u2502 202    \u2502 217.17    \u2502 \u2705      \u2502\n\u2502 POST   \u2502 /persona                            \u2502 202    \u2502 242.75    \u2502 \u2705      \u2502\n\u2502 POST   \u2502 /persona                            \u2502 400    \u2502 179.85    \u2502 \u274c      \u2502\n\u2502 POST   \u2502 /elevator/call                      \u2502 0      \u2502 6748.16   \u2502 \u274c      \u2502\n\u2502 POST   \u2502 /persona                            \u2502 400    \u2502 181.15    \u2502 \u274c      \u2502\n\u2502 GET    \u2502 /coordinator/missions/xxxxxxxxxxxx\u2026 \u2502 404    \u2502 188.92    \u2502 \u274c      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Performance Metrics \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 \ud83d\udcc8 Avg: 1074.78ms | \u26a1 Min: 172.60ms | \ud83d\udc0c Max: 15669.36ms                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\ud83d\udcbe Results exported to: api-test-results-20250807-130807.json\n"}}], "warnings": [{"message": "Unknown pytest.mark.slow - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html", "category": "PytestUnknownMarkWarning", "when": "collect", "filename": "c:\\Projects\\building-os-platform\\tests\\api\\test_performance.py", "lineno": 73}, {"message": "Unknown pytest.mark.slow - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html", "category": "PytestUnknownMarkWarning", "when": "collect", "filename": "c:\\Projects\\building-os-platform\\tests\\api\\test_performance.py", "lineno": 245}, {"message": "Unknown pytest.mark.load - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html", "category": "PytestUnknownMarkWarning", "when": "collect", "filename": "c:\\Projects\\building-os-platform\\tests\\api\\test_performance.py", "lineno": 246}]}