{"created": 1754773970.5201678, "duration": 240.55847930908203, "exitcode": 1, "root": "C:\\Projects\\building-os-platform\\tests\\api", "environment": {}, "summary": {"passed": 8, "failed": 25, "total": 33, "collected": 33}, "collectors": [{"nodeid": "", "outcome": "passed", "result": [{"nodeid": "__init__.py", "type": "Package"}]}, {"nodeid": "test_endpoints.py::TestPayloads", "outcome": "passed", "result": []}, {"nodeid": "test_endpoints.py::TestHealthEndpoint", "outcome": "passed", "result": [{"nodeid": "test_endpoints.py::TestHealthEndpoint::test_health_check_success", "type": "Function", "lineno": 14}, {"nodeid": "test_endpoints.py::TestHealthEndpoint::test_health_check_performance", "type": "Function", "lineno": 23}]}, {"nodeid": "test_endpoints.py::TestDirectorEndpoint", "outcome": "passed", "result": [{"nodeid": "test_endpoints.py::TestDirectorEndpoint::test_director_basic_request", "type": "Function", "lineno": 37}, {"nodeid": "test_endpoints.py::TestDirectorEndpoint::test_director_with_user_request", "type": "Function", "lineno": 46}, {"nodeid": "test_endpoints.py::TestDirectorEndpoint::test_director_with_user_id", "type": "Function", "lineno": 56}]}, {"nodeid": "test_endpoints.py::TestPersonaEndpoint", "outcome": "passed", "result": [{"nodeid": "test_endpoints.py::TestPersonaEndpoint::test_persona_valid_message", "type": "Function", "lineno": 68}, {"nodeid": "test_endpoints.py::TestPersonaEndpoint::test_persona_missing_user_id", "type": "Function", "lineno": 81}, {"nodeid": "test_endpoints.py::TestPersonaEndpoint::test_persona_missing_message", "type": "Function", "lineno": 89}, {"nodeid": "test_endpoints.py::TestPersonaEndpoint::test_persona_conversations", "type": "Function", "lineno": 97}]}, {"nodeid": "test_endpoints.py::TestElevatorEndpoint", "outcome": "passed", "result": [{"nodeid": "test_endpoints.py::TestElevatorEndpoint::test_elevator_call_basic", "type": "Function", "lineno": 109}, {"nodeid": "test_endpoints.py::TestElevatorEndpoint::test_elevator_missing_mission_id", "type": "Function", "lineno": 120}]}, {"nodeid": "test_endpoints.py::TestPSIMEndpoint", "outcome": "passed", "result": [{"nodeid": "test_endpoints.py::TestPSIMEndpoint::test_psim_search_basic", "type": "Function", "lineno": 132}, {"nodeid": "test_endpoints.py::TestPSIMEndpoint::test_psim_search_with_custom_query", "type": "Function", "lineno": 142}]}, {"nodeid": "test_endpoints.py::TestCoordinatorEndpoint", "outcome": "passed", "result": [{"nodeid": "test_endpoints.py::TestCoordinatorEndpoint::test_coordinator_mission_status", "type": "Function", "lineno": 155}, {"nodeid": "test_endpoints.py::TestCoordinatorEndpoint::test_coordinator_different_mission_id", "type": "Function", "lineno": 166}]}, {"nodeid": "test_endpoints.py::TestCORSHeaders", "outcome": "passed", "result": [{"nodeid": "test_endpoints.py::TestCORSHeaders::test_cors_headers_present[/health]", "type": "Function", "lineno": 178}, {"nodeid": "test_endpoints.py::TestCORSHeaders::test_cors_headers_present[/director]", "type": "Function", "lineno": 178}, {"nodeid": "test_endpoints.py::TestCORSHeaders::test_cors_headers_present[/persona]", "type": "Function", "lineno": 178}, {"nodeid": "test_endpoints.py::TestCORSHeaders::test_cors_headers_present[/elevator/call]", "type": "Function", "lineno": 178}, {"nodeid": "test_endpoints.py::TestCORSHeaders::test_cors_headers_present[/psim/search]", "type": "Function", "lineno": 178}, {"nodeid": "test_endpoints.py::TestCORSHeaders::test_cors_headers_present[/coordinator/missions/test-123]", "type": "Function", "lineno": 178}]}, {"nodeid": "test_endpoints.py::TestErrorHandling", "outcome": "passed", "result": [{"nodeid": "test_endpoints.py::TestErrorHandling::test_invalid_endpoint", "type": "Function", "lineno": 220}, {"nodeid": "test_endpoints.py::TestErrorHandling::test_invalid_method", "type": "Function", "lineno": 225}, {"nodeid": "test_endpoints.py::TestErrorHandling::test_malformed_json", "type": "Function", "lineno": 235}]}, {"nodeid": "test_endpoints.py", "outcome": "passed", "result": [{"nodeid": "test_endpoints.py::TestPayloads", "type": "Class"}, {"nodeid": "test_endpoints.py::TestHealthEndpoint", "type": "Class"}, {"nodeid": "test_endpoints.py::TestDirectorEndpoint", "type": "Class"}, {"nodeid": "test_endpoints.py::TestPersonaEndpoint", "type": "Class"}, {"nodeid": "test_endpoints.py::TestElevatorEndpoint", "type": "Class"}, {"nodeid": "test_endpoints.py::TestPSIMEndpoint", "type": "Class"}, {"nodeid": "test_endpoints.py::TestCoordinatorEndpoint", "type": "Class"}, {"nodeid": "test_endpoints.py::TestCORSHeaders", "type": "Class"}, {"nodeid": "test_endpoints.py::TestErrorHandling", "type": "Class"}]}, {"nodeid": "test_performance.py::TestPerformance", "outcome": "passed", "result": [{"nodeid": "test_performance.py::TestPerformance::test_response_time_under_threshold", "type": "Function", "lineno": 18}, {"nodeid": "test_performance.py::TestPerformance::test_concurrent_health_checks", "type": "Function", "lineno": 45}]}, {"nodeid": "test_performance.py::TestLoadTesting", "outcome": "passed", "result": [{"nodeid": "test_performance.py::TestLoadTesting::test_sustained_load_health_endpoint", "type": "Function", "lineno": 72}]}, {"nodeid": "test_performance.py::TestStressScenarios", "outcome": "passed", "result": [{"nodeid": "test_performance.py::TestStressScenarios::test_large_payload_persona", "type": "Function", "lineno": 149}, {"nodeid": "test_performance.py::TestStressScenarios::test_rapid_successive_requests", "type": "Function", "lineno": 163}, {"nodeid": "test_performance.py::TestStressScenarios::test_special_characters_in_requests", "type": "Function", "lineno": 189}]}, {"nodeid": "test_performance.py::TestBoundaryConditions", "outcome": "passed", "result": [{"nodeid": "test_performance.py::TestBoundaryConditions::test_empty_payloads", "type": "Function", "lineno": 213}, {"nodeid": "test_performance.py::TestBoundaryConditions::test_null_values_in_payload", "type": "Function", "lineno": 224}, {"nodeid": "test_performance.py::TestBoundaryConditions::test_extremely_long_mission_id", "type": "Function", "lineno": 233}]}, {"nodeid": "test_performance.py", "outcome": "passed", "result": [{"nodeid": "test_performance.py::TestPerformance", "type": "Class"}, {"nodeid": "test_performance.py::TestLoadTesting", "type": "Class"}, {"nodeid": "test_performance.py::TestStressScenarios", "type": "Class"}, {"nodeid": "test_performance.py::TestBoundaryConditions", "type": "Class"}]}, {"nodeid": "__init__.py", "outcome": "passed", "result": [{"nodeid": "test_endpoints.py", "type": "Module"}, {"nodeid": "test_performance.py", "type": "Module"}]}], "tests": [{"nodeid": "test_endpoints.py::TestHealthEndpoint::test_health_check_success", "lineno": 14, "outcome": "passed", "keywords": ["test_health_check_success", "TestHealthEndpoint", "test_endpoints.py", "__init__.py", "api"], "setup": {"duration": 0.016295500005071517, "outcome": "passed", "stdout": "\n\ud83e\uddea Starting BuildingOS API Test Suite\n\ud83c\udf10 Base URL: https://pj4vlvxrg7.execute-api.us-east-1.amazonaws.com/dev\n\ud83c\udff7\ufe0f  Environment: dev\n"}, "call": {"duration": 1.9190450000023702, "outcome": "passed", "stdout": "\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 1916.16ms | \ud83d\udce6 Size: 60 bytes\n"}, "teardown": {"duration": 0.0010543000025791116, "outcome": "passed", "stdout": "\n"}}, {"nodeid": "test_endpoints.py::TestHealthEndpoint::test_health_check_performance", "lineno": 23, "outcome": "passed", "keywords": ["test_health_check_performance", "TestHealthEndpoint", "test_endpoints.py", "__init__.py", "api"], "setup": {"duration": 0.0006877999985590577, "outcome": "passed"}, "call": {"duration": 0.2135777000003145, "outcome": "passed", "stdout": "\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 211.21ms | \ud83d\udce6 Size: 60 bytes\n"}, "teardown": {"duration": 0.0008960999984992668, "outcome": "passed", "stdout": "\n"}}, {"nodeid": "test_endpoints.py::TestDirectorEndpoint::test_director_basic_request", "lineno": 37, "outcome": "failed", "keywords": ["test_director_basic_request", "TestDirectorEndpoint", "test_endpoints.py", "__init__.py", "api"], "setup": {"duration": 0.0004951000009896234, "outcome": "passed"}, "call": {"duration": 9.226301099995908, "outcome": "failed", "crash": {"path": "C:\\Projects\\building-os-platform\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/director (Caused by ResponseError('too many 500 error responses'))"}, "traceback": [{"path": "test_endpoints.py", "lineno": 40, "message": ""}, {"path": "client.py", "lineno": 119, "message": "in get"}, {"path": "client.py", "lineno": 64, "message": "in make_request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 589, "message": "in request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 703, "message": "in send"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "RetryError"}], "stdout": "\n\ud83d\ude80 GET /director\n\u274c Request failed: \nHTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', \nport=443): Max retries exceeded with url: /dev/director (Caused by \nResponseError('too many 500 error responses'))\n", "longrepr": "urllib3.exceptions.ResponseError: too many 500 error responses\n\nThe above exception was the direct cause of the following exception:\n\nself = <requests.adapters.HTTPAdapter object at 0x000001E704969090>, request = <PreparedRequest [GET]>, stream = False, timeout = Timeout(connect=30, read=30, total=None), verify = True\ncert = None, proxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n>           resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:486: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:932: in urlopen\n    retries = retries.increment(method, url, response=response, _pool=self)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None), method = 'GET', url = '/dev/director', response = <urllib3.response.HTTPResponse object at 0x000001E705180100>\nerror = None, _pool = <urllib3.connectionpool.HTTPSConnectionPool object at 0x000001E704D41D30>, _stacktrace = None\n\n    def increment(\n        self,\n        method: str | None = None,\n        url: str | None = None,\n        response: BaseHTTPResponse | None = None,\n        error: Exception | None = None,\n        _pool: ConnectionPool | None = None,\n        _stacktrace: TracebackType | None = None,\n    ) -> Self:\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or method is None or not self._is_method_retryable(method):\n                raise reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            response_redirect_location = response.get_redirect_location()\n            if response_redirect_location:\n                redirect_location = response_redirect_location\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n            reason = error or ResponseError(cause)\n>           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\nE           urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/director (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:519: MaxRetryError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <api.test_endpoints.TestDirectorEndpoint object at 0x000001E70496A5D0>\n\n    def test_director_basic_request(self):\n        \"\"\"Test director without parameters\"\"\"\n>       response, data = client.get(\"/director\")\n\ntest_endpoints.py:40: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nclient.py:119: in get\n    return self.make_request(\"GET\", endpoint, **kwargs)\nclient.py:64: in make_request\n    response = self.session.request(\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:589: in request\n    resp = self.send(prep, **send_kwargs)\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:703: in send\n    r = adapter.send(request, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <requests.adapters.HTTPAdapter object at 0x000001E704969090>, request = <PreparedRequest [GET]>, stream = False, timeout = Timeout(connect=30, read=30, total=None), verify = True\ncert = None, proxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n            resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n    \n        except (ProtocolError, OSError) as err:\n            raise ConnectionError(err, request=request)\n    \n        except MaxRetryError as e:\n            if isinstance(e.reason, ConnectTimeoutError):\n                # TODO: Remove this in 3.0.0: see #2811\n                if not isinstance(e.reason, NewConnectionError):\n                    raise ConnectTimeout(e, request=request)\n    \n            if isinstance(e.reason, ResponseError):\n>               raise RetryError(e, request=request)\nE               requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/director (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:510: RetryError"}, "teardown": {"duration": 0.0013964999961899593, "outcome": "passed", "stdout": "\n"}}, {"nodeid": "test_endpoints.py::TestDirectorEndpoint::test_director_with_user_request", "lineno": 46, "outcome": "failed", "keywords": ["test_director_with_user_request", "TestDirectorEndpoint", "test_endpoints.py", "__init__.py", "api"], "setup": {"duration": 0.0010531000007176772, "outcome": "passed"}, "call": {"duration": 8.417588999996951, "outcome": "failed", "crash": {"path": "C:\\Projects\\building-os-platform\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/director?user_request=Test%20mission%20from%20Python%20API%20tests (Caused by ResponseError('too many 500 error responses'))"}, "traceback": [{"path": "test_endpoints.py", "lineno": 50, "message": ""}, {"path": "client.py", "lineno": 119, "message": "in get"}, {"path": "client.py", "lineno": 64, "message": "in make_request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 589, "message": "in request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 703, "message": "in send"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "RetryError"}], "stdout": "\n\ud83d\ude80 GET /director?user_request=Test mission from Python API tests\n\u274c Request failed: \nHTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', \nport=443): Max retries exceeded with url: \n/dev/director?user_request=Test%20mission%20from%20Python%20API%20tests (Caused\nby ResponseError('too many 500 error responses'))\n", "longrepr": "urllib3.exceptions.ResponseError: too many 500 error responses\n\nThe above exception was the direct cause of the following exception:\n\nself = <requests.adapters.HTTPAdapter object at 0x000001E704969090>, request = <PreparedRequest [GET]>, stream = False, timeout = Timeout(connect=30, read=30, total=None), verify = True\ncert = None, proxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n>           resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:486: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:932: in urlopen\n    retries = retries.increment(method, url, response=response, _pool=self)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None), method = 'GET', url = '/dev/director?user_request=Test%20mission%20from%20Python%20API%20tests'\nresponse = <urllib3.response.HTTPResponse object at 0x000001E705182D40>, error = None, _pool = <urllib3.connectionpool.HTTPSConnectionPool object at 0x000001E704D41D30>, _stacktrace = None\n\n    def increment(\n        self,\n        method: str | None = None,\n        url: str | None = None,\n        response: BaseHTTPResponse | None = None,\n        error: Exception | None = None,\n        _pool: ConnectionPool | None = None,\n        _stacktrace: TracebackType | None = None,\n    ) -> Self:\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or method is None or not self._is_method_retryable(method):\n                raise reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            response_redirect_location = response.get_redirect_location()\n            if response_redirect_location:\n                redirect_location = response_redirect_location\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n            reason = error or ResponseError(cause)\n>           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\nE           urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/director?user_request=Test%20mission%20from%20Python%20API%20tests (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:519: MaxRetryError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <api.test_endpoints.TestDirectorEndpoint object at 0x000001E70496A350>\n\n    def test_director_with_user_request(self):\n        \"\"\"Test director with user request parameter\"\"\"\n        user_request = \"Test mission from Python API tests\"\n>       response, data = client.get(f\"/director?user_request={user_request}\")\n\ntest_endpoints.py:50: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nclient.py:119: in get\n    return self.make_request(\"GET\", endpoint, **kwargs)\nclient.py:64: in make_request\n    response = self.session.request(\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:589: in request\n    resp = self.send(prep, **send_kwargs)\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:703: in send\n    r = adapter.send(request, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <requests.adapters.HTTPAdapter object at 0x000001E704969090>, request = <PreparedRequest [GET]>, stream = False, timeout = Timeout(connect=30, read=30, total=None), verify = True\ncert = None, proxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n            resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n    \n        except (ProtocolError, OSError) as err:\n            raise ConnectionError(err, request=request)\n    \n        except MaxRetryError as e:\n            if isinstance(e.reason, ConnectTimeoutError):\n                # TODO: Remove this in 3.0.0: see #2811\n                if not isinstance(e.reason, NewConnectionError):\n                    raise ConnectTimeout(e, request=request)\n    \n            if isinstance(e.reason, ResponseError):\n>               raise RetryError(e, request=request)\nE               requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/director?user_request=Test%20mission%20from%20Python%20API%20tests (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:510: RetryError"}, "teardown": {"duration": 0.0010188999949605204, "outcome": "passed", "stdout": "\n"}}, {"nodeid": "test_endpoints.py::TestDirectorEndpoint::test_director_with_user_id", "lineno": 56, "outcome": "failed", "keywords": ["test_director_with_user_id", "TestDirectorEndpoint", "test_endpoints.py", "__init__.py", "api"], "setup": {"duration": 0.0009644999954616651, "outcome": "passed"}, "call": {"duration": 8.378866400002153, "outcome": "failed", "crash": {"path": "C:\\Projects\\building-os-platform\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/director?user_id=api-test-user (Caused by ResponseError('too many 500 error responses'))"}, "traceback": [{"path": "test_endpoints.py", "lineno": 60, "message": ""}, {"path": "client.py", "lineno": 119, "message": "in get"}, {"path": "client.py", "lineno": 64, "message": "in make_request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 589, "message": "in request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 703, "message": "in send"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "RetryError"}], "stdout": "\n\ud83d\ude80 GET /director?user_id=api-test-user\n\u274c Request failed: \nHTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', \nport=443): Max retries exceeded with url: /dev/director?user_id=api-test-user \n(Caused by ResponseError('too many 500 error responses'))\n", "longrepr": "urllib3.exceptions.ResponseError: too many 500 error responses\n\nThe above exception was the direct cause of the following exception:\n\nself = <requests.adapters.HTTPAdapter object at 0x000001E704969090>, request = <PreparedRequest [GET]>, stream = False, timeout = Timeout(connect=30, read=30, total=None), verify = True\ncert = None, proxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n>           resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:486: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:932: in urlopen\n    retries = retries.increment(method, url, response=response, _pool=self)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None), method = 'GET', url = '/dev/director?user_id=api-test-user'\nresponse = <urllib3.response.HTTPResponse object at 0x000001E705182F80>, error = None, _pool = <urllib3.connectionpool.HTTPSConnectionPool object at 0x000001E704D41D30>, _stacktrace = None\n\n    def increment(\n        self,\n        method: str | None = None,\n        url: str | None = None,\n        response: BaseHTTPResponse | None = None,\n        error: Exception | None = None,\n        _pool: ConnectionPool | None = None,\n        _stacktrace: TracebackType | None = None,\n    ) -> Self:\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or method is None or not self._is_method_retryable(method):\n                raise reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            response_redirect_location = response.get_redirect_location()\n            if response_redirect_location:\n                redirect_location = response_redirect_location\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n            reason = error or ResponseError(cause)\n>           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\nE           urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/director?user_id=api-test-user (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:519: MaxRetryError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <api.test_endpoints.TestDirectorEndpoint object at 0x000001E70493AFD0>\n\n    def test_director_with_user_id(self):\n        \"\"\"Test director with user_id parameter\"\"\"\n        user_id = config.test_user_id\n>       response, data = client.get(f\"/director?user_id={user_id}\")\n\ntest_endpoints.py:60: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nclient.py:119: in get\n    return self.make_request(\"GET\", endpoint, **kwargs)\nclient.py:64: in make_request\n    response = self.session.request(\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:589: in request\n    resp = self.send(prep, **send_kwargs)\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:703: in send\n    r = adapter.send(request, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <requests.adapters.HTTPAdapter object at 0x000001E704969090>, request = <PreparedRequest [GET]>, stream = False, timeout = Timeout(connect=30, read=30, total=None), verify = True\ncert = None, proxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n            resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n    \n        except (ProtocolError, OSError) as err:\n            raise ConnectionError(err, request=request)\n    \n        except MaxRetryError as e:\n            if isinstance(e.reason, ConnectTimeoutError):\n                # TODO: Remove this in 3.0.0: see #2811\n                if not isinstance(e.reason, NewConnectionError):\n                    raise ConnectTimeout(e, request=request)\n    \n            if isinstance(e.reason, ResponseError):\n>               raise RetryError(e, request=request)\nE               requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/director?user_id=api-test-user (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:510: RetryError"}, "teardown": {"duration": 0.001033099993946962, "outcome": "passed", "stdout": "\n"}}, {"nodeid": "test_endpoints.py::TestPersonaEndpoint::test_persona_valid_message", "lineno": 68, "outcome": "failed", "keywords": ["test_persona_valid_message", "TestPersonaEndpoint", "test_endpoints.py", "__init__.py", "api"], "setup": {"duration": 0.0009204000016325153, "outcome": "passed"}, "call": {"duration": 9.103625199997623, "outcome": "failed", "crash": {"path": "C:\\Projects\\building-os-platform\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/persona (Caused by ResponseError('too many 500 error responses'))"}, "traceback": [{"path": "test_endpoints.py", "lineno": 72, "message": ""}, {"path": "client.py", "lineno": 122, "message": "in post"}, {"path": "client.py", "lineno": 64, "message": "in make_request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 589, "message": "in request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 703, "message": "in send"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "RetryError"}], "stdout": "\n\ud83d\ude80 POST /persona\n\u274c Request failed: \nHTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', \nport=443): Max retries exceeded with url: /dev/persona (Caused by \nResponseError('too many 500 error responses'))\n", "longrepr": "urllib3.exceptions.ResponseError: too many 500 error responses\n\nThe above exception was the direct cause of the following exception:\n\nself = <requests.adapters.HTTPAdapter object at 0x000001E704969090>, request = <PreparedRequest [POST]>, stream = False, timeout = Timeout(connect=30, read=30, total=None), verify = True\ncert = None, proxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n>           resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:486: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:932: in urlopen\n    retries = retries.increment(method, url, response=response, _pool=self)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None), method = 'POST', url = '/dev/persona', response = <urllib3.response.HTTPResponse object at 0x000001E705182440>\nerror = None, _pool = <urllib3.connectionpool.HTTPSConnectionPool object at 0x000001E704D41D30>, _stacktrace = None\n\n    def increment(\n        self,\n        method: str | None = None,\n        url: str | None = None,\n        response: BaseHTTPResponse | None = None,\n        error: Exception | None = None,\n        _pool: ConnectionPool | None = None,\n        _stacktrace: TracebackType | None = None,\n    ) -> Self:\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or method is None or not self._is_method_retryable(method):\n                raise reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            response_redirect_location = response.get_redirect_location()\n            if response_redirect_location:\n                redirect_location = response_redirect_location\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n            reason = error or ResponseError(cause)\n>           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\nE           urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/persona (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:519: MaxRetryError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <api.test_endpoints.TestPersonaEndpoint object at 0x000001E70496A710>\n\n    def test_persona_valid_message(self):\n        \"\"\"Test persona with valid message\"\"\"\n        payload = TestPayloads.persona_message()\n>       response, data = client.post(\"/persona\", json=payload)\n\ntest_endpoints.py:72: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nclient.py:122: in post\n    return self.make_request(\"POST\", endpoint, **kwargs)\nclient.py:64: in make_request\n    response = self.session.request(\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:589: in request\n    resp = self.send(prep, **send_kwargs)\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:703: in send\n    r = adapter.send(request, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <requests.adapters.HTTPAdapter object at 0x000001E704969090>, request = <PreparedRequest [POST]>, stream = False, timeout = Timeout(connect=30, read=30, total=None), verify = True\ncert = None, proxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n            resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n    \n        except (ProtocolError, OSError) as err:\n            raise ConnectionError(err, request=request)\n    \n        except MaxRetryError as e:\n            if isinstance(e.reason, ConnectTimeoutError):\n                # TODO: Remove this in 3.0.0: see #2811\n                if not isinstance(e.reason, NewConnectionError):\n                    raise ConnectTimeout(e, request=request)\n    \n            if isinstance(e.reason, ResponseError):\n>               raise RetryError(e, request=request)\nE               requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/persona (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:510: RetryError"}, "teardown": {"duration": 0.0010507999977562577, "outcome": "passed", "stdout": "\n"}}, {"nodeid": "test_endpoints.py::TestPersonaEndpoint::test_persona_missing_user_id", "lineno": 81, "outcome": "failed", "keywords": ["test_persona_missing_user_id", "TestPersonaEndpoint", "test_endpoints.py", "__init__.py", "api"], "setup": {"duration": 0.000974599999608472, "outcome": "passed"}, "call": {"duration": 8.236067799996817, "outcome": "failed", "crash": {"path": "C:\\Projects\\building-os-platform\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/persona (Caused by ResponseError('too many 500 error responses'))"}, "traceback": [{"path": "test_endpoints.py", "lineno": 85, "message": ""}, {"path": "client.py", "lineno": 122, "message": "in post"}, {"path": "client.py", "lineno": 64, "message": "in make_request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 589, "message": "in request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 703, "message": "in send"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "RetryError"}], "stdout": "\n\ud83d\ude80 POST /persona\n\u274c Request failed: \nHTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', \nport=443): Max retries exceeded with url: /dev/persona (Caused by \nResponseError('too many 500 error responses'))\n", "longrepr": "urllib3.exceptions.ResponseError: too many 500 error responses\n\nThe above exception was the direct cause of the following exception:\n\nself = <requests.adapters.HTTPAdapter object at 0x000001E704969090>, request = <PreparedRequest [POST]>, stream = False, timeout = Timeout(connect=30, read=30, total=None), verify = True\ncert = None, proxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n>           resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:486: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:932: in urlopen\n    retries = retries.increment(method, url, response=response, _pool=self)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None), method = 'POST', url = '/dev/persona', response = <urllib3.response.HTTPResponse object at 0x000001E7051BFE50>\nerror = None, _pool = <urllib3.connectionpool.HTTPSConnectionPool object at 0x000001E704D41D30>, _stacktrace = None\n\n    def increment(\n        self,\n        method: str | None = None,\n        url: str | None = None,\n        response: BaseHTTPResponse | None = None,\n        error: Exception | None = None,\n        _pool: ConnectionPool | None = None,\n        _stacktrace: TracebackType | None = None,\n    ) -> Self:\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or method is None or not self._is_method_retryable(method):\n                raise reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            response_redirect_location = response.get_redirect_location()\n            if response_redirect_location:\n                redirect_location = response_redirect_location\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n            reason = error or ResponseError(cause)\n>           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\nE           urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/persona (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:519: MaxRetryError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <api.test_endpoints.TestPersonaEndpoint object at 0x000001E70496A850>\n\n    def test_persona_missing_user_id(self):\n        \"\"\"Test persona without user_id\"\"\"\n        payload = {\"message\": \"Test message\"}\n>       response, data = client.post(\"/persona\", json=payload)\n\ntest_endpoints.py:85: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nclient.py:122: in post\n    return self.make_request(\"POST\", endpoint, **kwargs)\nclient.py:64: in make_request\n    response = self.session.request(\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:589: in request\n    resp = self.send(prep, **send_kwargs)\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:703: in send\n    r = adapter.send(request, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <requests.adapters.HTTPAdapter object at 0x000001E704969090>, request = <PreparedRequest [POST]>, stream = False, timeout = Timeout(connect=30, read=30, total=None), verify = True\ncert = None, proxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n            resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n    \n        except (ProtocolError, OSError) as err:\n            raise ConnectionError(err, request=request)\n    \n        except MaxRetryError as e:\n            if isinstance(e.reason, ConnectTimeoutError):\n                # TODO: Remove this in 3.0.0: see #2811\n                if not isinstance(e.reason, NewConnectionError):\n                    raise ConnectTimeout(e, request=request)\n    \n            if isinstance(e.reason, ResponseError):\n>               raise RetryError(e, request=request)\nE               requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/persona (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:510: RetryError"}, "teardown": {"duration": 0.001261299999896437, "outcome": "passed", "stdout": "\n"}}, {"nodeid": "test_endpoints.py::TestPersonaEndpoint::test_persona_missing_message", "lineno": 89, "outcome": "failed", "keywords": ["test_persona_missing_message", "TestPersonaEndpoint", "test_endpoints.py", "__init__.py", "api"], "setup": {"duration": 0.0008518000031472184, "outcome": "passed"}, "call": {"duration": 8.287512499999139, "outcome": "failed", "crash": {"path": "C:\\Projects\\building-os-platform\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/persona (Caused by ResponseError('too many 500 error responses'))"}, "traceback": [{"path": "test_endpoints.py", "lineno": 93, "message": ""}, {"path": "client.py", "lineno": 122, "message": "in post"}, {"path": "client.py", "lineno": 64, "message": "in make_request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 589, "message": "in request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 703, "message": "in send"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "RetryError"}], "stdout": "\n\ud83d\ude80 POST /persona\n\u274c Request failed: \nHTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', \nport=443): Max retries exceeded with url: /dev/persona (Caused by \nResponseError('too many 500 error responses'))\n", "longrepr": "urllib3.exceptions.ResponseError: too many 500 error responses\n\nThe above exception was the direct cause of the following exception:\n\nself = <requests.adapters.HTTPAdapter object at 0x000001E704969090>, request = <PreparedRequest [POST]>, stream = False, timeout = Timeout(connect=30, read=30, total=None), verify = True\ncert = None, proxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n>           resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:486: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:932: in urlopen\n    retries = retries.increment(method, url, response=response, _pool=self)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None), method = 'POST', url = '/dev/persona', response = <urllib3.response.HTTPResponse object at 0x000001E7051BEFB0>\nerror = None, _pool = <urllib3.connectionpool.HTTPSConnectionPool object at 0x000001E704D41D30>, _stacktrace = None\n\n    def increment(\n        self,\n        method: str | None = None,\n        url: str | None = None,\n        response: BaseHTTPResponse | None = None,\n        error: Exception | None = None,\n        _pool: ConnectionPool | None = None,\n        _stacktrace: TracebackType | None = None,\n    ) -> Self:\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or method is None or not self._is_method_retryable(method):\n                raise reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            response_redirect_location = response.get_redirect_location()\n            if response_redirect_location:\n                redirect_location = response_redirect_location\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n            reason = error or ResponseError(cause)\n>           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\nE           urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/persona (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:519: MaxRetryError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <api.test_endpoints.TestPersonaEndpoint object at 0x000001E70493A520>\n\n    def test_persona_missing_message(self):\n        \"\"\"Test persona without message\"\"\"\n        payload = {\"user_id\": config.test_user_id}\n>       response, data = client.post(\"/persona\", json=payload)\n\ntest_endpoints.py:93: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nclient.py:122: in post\n    return self.make_request(\"POST\", endpoint, **kwargs)\nclient.py:64: in make_request\n    response = self.session.request(\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:589: in request\n    resp = self.send(prep, **send_kwargs)\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:703: in send\n    r = adapter.send(request, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <requests.adapters.HTTPAdapter object at 0x000001E704969090>, request = <PreparedRequest [POST]>, stream = False, timeout = Timeout(connect=30, read=30, total=None), verify = True\ncert = None, proxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n            resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n    \n        except (ProtocolError, OSError) as err:\n            raise ConnectionError(err, request=request)\n    \n        except MaxRetryError as e:\n            if isinstance(e.reason, ConnectTimeoutError):\n                # TODO: Remove this in 3.0.0: see #2811\n                if not isinstance(e.reason, NewConnectionError):\n                    raise ConnectTimeout(e, request=request)\n    \n            if isinstance(e.reason, ResponseError):\n>               raise RetryError(e, request=request)\nE               requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/persona (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:510: RetryError"}, "teardown": {"duration": 0.0010388000009697862, "outcome": "passed", "stdout": "\n"}}, {"nodeid": "test_endpoints.py::TestPersonaEndpoint::test_persona_conversations", "lineno": 97, "outcome": "failed", "keywords": ["test_persona_conversations", "TestPersonaEndpoint", "test_endpoints.py", "__init__.py", "api"], "setup": {"duration": 0.0006884999966132455, "outcome": "passed"}, "call": {"duration": 8.211323000003176, "outcome": "failed", "crash": {"path": "C:\\Projects\\building-os-platform\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/persona/conversations?user_id=api-test-user (Caused by ResponseError('too many 500 error responses'))"}, "traceback": [{"path": "test_endpoints.py", "lineno": 101, "message": ""}, {"path": "client.py", "lineno": 119, "message": "in get"}, {"path": "client.py", "lineno": 64, "message": "in make_request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 589, "message": "in request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 703, "message": "in send"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "RetryError"}], "stdout": "\n\ud83d\ude80 GET /persona/conversations?user_id=api-test-user\n\u274c Request failed: \nHTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', \nport=443): Max retries exceeded with url: \n/dev/persona/conversations?user_id=api-test-user (Caused by ResponseError('too \nmany 500 error responses'))\n", "longrepr": "urllib3.exceptions.ResponseError: too many 500 error responses\n\nThe above exception was the direct cause of the following exception:\n\nself = <requests.adapters.HTTPAdapter object at 0x000001E704969090>, request = <PreparedRequest [GET]>, stream = False, timeout = Timeout(connect=30, read=30, total=None), verify = True\ncert = None, proxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n>           resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:486: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:932: in urlopen\n    retries = retries.increment(method, url, response=response, _pool=self)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None), method = 'GET', url = '/dev/persona/conversations?user_id=api-test-user'\nresponse = <urllib3.response.HTTPResponse object at 0x000001E7051BE410>, error = None, _pool = <urllib3.connectionpool.HTTPSConnectionPool object at 0x000001E704D41D30>, _stacktrace = None\n\n    def increment(\n        self,\n        method: str | None = None,\n        url: str | None = None,\n        response: BaseHTTPResponse | None = None,\n        error: Exception | None = None,\n        _pool: ConnectionPool | None = None,\n        _stacktrace: TracebackType | None = None,\n    ) -> Self:\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or method is None or not self._is_method_retryable(method):\n                raise reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            response_redirect_location = response.get_redirect_location()\n            if response_redirect_location:\n                redirect_location = response_redirect_location\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n            reason = error or ResponseError(cause)\n>           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\nE           urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/persona/conversations?user_id=api-test-user (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:519: MaxRetryError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <api.test_endpoints.TestPersonaEndpoint object at 0x000001E70493B100>\n\n    def test_persona_conversations(self):\n        \"\"\"Test persona conversations endpoint\"\"\"\n        user_id = config.test_user_id\n>       response, data = client.get(f\"/persona/conversations?user_id={user_id}\")\n\ntest_endpoints.py:101: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nclient.py:119: in get\n    return self.make_request(\"GET\", endpoint, **kwargs)\nclient.py:64: in make_request\n    response = self.session.request(\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:589: in request\n    resp = self.send(prep, **send_kwargs)\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:703: in send\n    r = adapter.send(request, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <requests.adapters.HTTPAdapter object at 0x000001E704969090>, request = <PreparedRequest [GET]>, stream = False, timeout = Timeout(connect=30, read=30, total=None), verify = True\ncert = None, proxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n            resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n    \n        except (ProtocolError, OSError) as err:\n            raise ConnectionError(err, request=request)\n    \n        except MaxRetryError as e:\n            if isinstance(e.reason, ConnectTimeoutError):\n                # TODO: Remove this in 3.0.0: see #2811\n                if not isinstance(e.reason, NewConnectionError):\n                    raise ConnectTimeout(e, request=request)\n    \n            if isinstance(e.reason, ResponseError):\n>               raise RetryError(e, request=request)\nE               requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/persona/conversations?user_id=api-test-user (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:510: RetryError"}, "teardown": {"duration": 0.0012436999968485907, "outcome": "passed", "stdout": "\n"}}, {"nodeid": "test_endpoints.py::TestElevatorEndpoint::test_elevator_call_basic", "lineno": 109, "outcome": "failed", "keywords": ["test_elevator_call_basic", "TestElevatorEndpoint", "test_endpoints.py", "__init__.py", "api"], "setup": {"duration": 0.0012170999980298802, "outcome": "passed"}, "call": {"duration": 8.298799899996084, "outcome": "failed", "crash": {"path": "C:\\Projects\\building-os-platform\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/elevator/call (Caused by ResponseError('too many 500 error responses'))"}, "traceback": [{"path": "test_endpoints.py", "lineno": 113, "message": ""}, {"path": "client.py", "lineno": 122, "message": "in post"}, {"path": "client.py", "lineno": 64, "message": "in make_request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 589, "message": "in request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 703, "message": "in send"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "RetryError"}], "stdout": "\n\ud83d\ude80 POST /elevator/call\n\u274c Request failed: \nHTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', \nport=443): Max retries exceeded with url: /dev/elevator/call (Caused by \nResponseError('too many 500 error responses'))\n", "longrepr": "urllib3.exceptions.ResponseError: too many 500 error responses\n\nThe above exception was the direct cause of the following exception:\n\nself = <requests.adapters.HTTPAdapter object at 0x000001E704969090>, request = <PreparedRequest [POST]>, stream = False, timeout = Timeout(connect=30, read=30, total=None), verify = True\ncert = None, proxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n>           resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:486: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:932: in urlopen\n    retries = retries.increment(method, url, response=response, _pool=self)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None), method = 'POST', url = '/dev/elevator/call', response = <urllib3.response.HTTPResponse object at 0x000001E705181EA0>\nerror = None, _pool = <urllib3.connectionpool.HTTPSConnectionPool object at 0x000001E704D41D30>, _stacktrace = None\n\n    def increment(\n        self,\n        method: str | None = None,\n        url: str | None = None,\n        response: BaseHTTPResponse | None = None,\n        error: Exception | None = None,\n        _pool: ConnectionPool | None = None,\n        _stacktrace: TracebackType | None = None,\n    ) -> Self:\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or method is None or not self._is_method_retryable(method):\n                raise reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            response_redirect_location = response.get_redirect_location()\n            if response_redirect_location:\n                redirect_location = response_redirect_location\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n            reason = error or ResponseError(cause)\n>           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\nE           urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/elevator/call (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:519: MaxRetryError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <api.test_endpoints.TestElevatorEndpoint object at 0x000001E70496A990>\n\n    def test_elevator_call_basic(self):\n        \"\"\"Test basic elevator call\"\"\"\n        payload = TestPayloads.elevator_call()\n>       response, data = client.post(\"/elevator/call\", json=payload)\n\ntest_endpoints.py:113: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nclient.py:122: in post\n    return self.make_request(\"POST\", endpoint, **kwargs)\nclient.py:64: in make_request\n    response = self.session.request(\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:589: in request\n    resp = self.send(prep, **send_kwargs)\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:703: in send\n    r = adapter.send(request, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <requests.adapters.HTTPAdapter object at 0x000001E704969090>, request = <PreparedRequest [POST]>, stream = False, timeout = Timeout(connect=30, read=30, total=None), verify = True\ncert = None, proxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n            resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n    \n        except (ProtocolError, OSError) as err:\n            raise ConnectionError(err, request=request)\n    \n        except MaxRetryError as e:\n            if isinstance(e.reason, ConnectTimeoutError):\n                # TODO: Remove this in 3.0.0: see #2811\n                if not isinstance(e.reason, NewConnectionError):\n                    raise ConnectTimeout(e, request=request)\n    \n            if isinstance(e.reason, ResponseError):\n>               raise RetryError(e, request=request)\nE               requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/elevator/call (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:510: RetryError"}, "teardown": {"duration": 0.0011704999997164123, "outcome": "passed", "stdout": "\n"}}, {"nodeid": "test_endpoints.py::TestElevatorEndpoint::test_elevator_missing_mission_id", "lineno": 120, "outcome": "failed", "keywords": ["test_elevator_missing_mission_id", "TestElevatorEndpoint", "test_endpoints.py", "__init__.py", "api"], "setup": {"duration": 0.003056599998672027, "outcome": "passed"}, "call": {"duration": 7.745103299996117, "outcome": "failed", "crash": {"path": "C:\\Projects\\building-os-platform\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/elevator/call (Caused by ResponseError('too many 500 error responses'))"}, "traceback": [{"path": "test_endpoints.py", "lineno": 124, "message": ""}, {"path": "client.py", "lineno": 122, "message": "in post"}, {"path": "client.py", "lineno": 64, "message": "in make_request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 589, "message": "in request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 703, "message": "in send"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "RetryError"}], "stdout": "\n\ud83d\ude80 POST /elevator/call\n\u274c Request failed: \nHTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', \nport=443): Max retries exceeded with url: /dev/elevator/call (Caused by \nResponseError('too many 500 error responses'))\n", "longrepr": "urllib3.exceptions.ResponseError: too many 500 error responses\n\nThe above exception was the direct cause of the following exception:\n\nself = <requests.adapters.HTTPAdapter object at 0x000001E704969090>, request = <PreparedRequest [POST]>, stream = False, timeout = Timeout(connect=30, read=30, total=None), verify = True\ncert = None, proxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n>           resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:486: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:932: in urlopen\n    retries = retries.increment(method, url, response=response, _pool=self)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None), method = 'POST', url = '/dev/elevator/call', response = <urllib3.response.HTTPResponse object at 0x000001E7051BE080>\nerror = None, _pool = <urllib3.connectionpool.HTTPSConnectionPool object at 0x000001E704D41D30>, _stacktrace = None\n\n    def increment(\n        self,\n        method: str | None = None,\n        url: str | None = None,\n        response: BaseHTTPResponse | None = None,\n        error: Exception | None = None,\n        _pool: ConnectionPool | None = None,\n        _stacktrace: TracebackType | None = None,\n    ) -> Self:\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or method is None or not self._is_method_retryable(method):\n                raise reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            response_redirect_location = response.get_redirect_location()\n            if response_redirect_location:\n                redirect_location = response_redirect_location\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n            reason = error or ResponseError(cause)\n>           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\nE           urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/elevator/call (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:519: MaxRetryError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <api.test_endpoints.TestElevatorEndpoint object at 0x000001E70496AAD0>\n\n    def test_elevator_missing_mission_id(self):\n        \"\"\"Test elevator call without mission_id\"\"\"\n        payload = {\"action\": \"call_elevator\", \"parameters\": {\"floor\": 3}}\n>       response, data = client.post(\"/elevator/call\", json=payload)\n\ntest_endpoints.py:124: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nclient.py:122: in post\n    return self.make_request(\"POST\", endpoint, **kwargs)\nclient.py:64: in make_request\n    response = self.session.request(\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:589: in request\n    resp = self.send(prep, **send_kwargs)\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:703: in send\n    r = adapter.send(request, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <requests.adapters.HTTPAdapter object at 0x000001E704969090>, request = <PreparedRequest [POST]>, stream = False, timeout = Timeout(connect=30, read=30, total=None), verify = True\ncert = None, proxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n            resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n    \n        except (ProtocolError, OSError) as err:\n            raise ConnectionError(err, request=request)\n    \n        except MaxRetryError as e:\n            if isinstance(e.reason, ConnectTimeoutError):\n                # TODO: Remove this in 3.0.0: see #2811\n                if not isinstance(e.reason, NewConnectionError):\n                    raise ConnectTimeout(e, request=request)\n    \n            if isinstance(e.reason, ResponseError):\n>               raise RetryError(e, request=request)\nE               requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/elevator/call (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:510: RetryError"}, "teardown": {"duration": 0.0010962000014842488, "outcome": "passed", "stdout": "\n"}}, {"nodeid": "test_endpoints.py::TestPSIMEndpoint::test_psim_search_basic", "lineno": 132, "outcome": "failed", "keywords": ["test_psim_search_basic", "TestPSIMEndpoint", "test_endpoints.py", "__init__.py", "api"], "setup": {"duration": 0.0009882000013021752, "outcome": "passed"}, "call": {"duration": 8.309036300001026, "outcome": "failed", "crash": {"path": "C:\\Projects\\building-os-platform\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/psim/search (Caused by ResponseError('too many 500 error responses'))"}, "traceback": [{"path": "test_endpoints.py", "lineno": 136, "message": ""}, {"path": "client.py", "lineno": 122, "message": "in post"}, {"path": "client.py", "lineno": 64, "message": "in make_request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 589, "message": "in request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 703, "message": "in send"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "RetryError"}], "stdout": "\n\ud83d\ude80 POST /psim/search\n\u274c Request failed: \nHTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', \nport=443): Max retries exceeded with url: /dev/psim/search (Caused by \nResponseError('too many 500 error responses'))\n", "longrepr": "urllib3.exceptions.ResponseError: too many 500 error responses\n\nThe above exception was the direct cause of the following exception:\n\nself = <requests.adapters.HTTPAdapter object at 0x000001E704969090>, request = <PreparedRequest [POST]>, stream = False, timeout = Timeout(connect=30, read=30, total=None), verify = True\ncert = None, proxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n>           resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:486: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:932: in urlopen\n    retries = retries.increment(method, url, response=response, _pool=self)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None), method = 'POST', url = '/dev/psim/search', response = <urllib3.response.HTTPResponse object at 0x000001E70522A0B0>\nerror = None, _pool = <urllib3.connectionpool.HTTPSConnectionPool object at 0x000001E704D41D30>, _stacktrace = None\n\n    def increment(\n        self,\n        method: str | None = None,\n        url: str | None = None,\n        response: BaseHTTPResponse | None = None,\n        error: Exception | None = None,\n        _pool: ConnectionPool | None = None,\n        _stacktrace: TracebackType | None = None,\n    ) -> Self:\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or method is None or not self._is_method_retryable(method):\n                raise reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            response_redirect_location = response.get_redirect_location()\n            if response_redirect_location:\n                redirect_location = response_redirect_location\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n            reason = error or ResponseError(cause)\n>           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\nE           urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/psim/search (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:519: MaxRetryError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <api.test_endpoints.TestPSIMEndpoint object at 0x000001E70496AC10>\n\n    def test_psim_search_basic(self):\n        \"\"\"Test basic PSIM search\"\"\"\n        payload = TestPayloads.psim_search()\n>       response, data = client.post(\"/psim/search\", json=payload)\n\ntest_endpoints.py:136: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nclient.py:122: in post\n    return self.make_request(\"POST\", endpoint, **kwargs)\nclient.py:64: in make_request\n    response = self.session.request(\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:589: in request\n    resp = self.send(prep, **send_kwargs)\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:703: in send\n    r = adapter.send(request, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <requests.adapters.HTTPAdapter object at 0x000001E704969090>, request = <PreparedRequest [POST]>, stream = False, timeout = Timeout(connect=30, read=30, total=None), verify = True\ncert = None, proxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n            resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n    \n        except (ProtocolError, OSError) as err:\n            raise ConnectionError(err, request=request)\n    \n        except MaxRetryError as e:\n            if isinstance(e.reason, ConnectTimeoutError):\n                # TODO: Remove this in 3.0.0: see #2811\n                if not isinstance(e.reason, NewConnectionError):\n                    raise ConnectTimeout(e, request=request)\n    \n            if isinstance(e.reason, ResponseError):\n>               raise RetryError(e, request=request)\nE               requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/psim/search (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:510: RetryError"}, "teardown": {"duration": 0.0010848000019905157, "outcome": "passed", "stdout": "\n"}}, {"nodeid": "test_endpoints.py::TestPSIMEndpoint::test_psim_search_with_custom_query", "lineno": 142, "outcome": "failed", "keywords": ["test_psim_search_with_custom_query", "TestPSIMEndpoint", "test_endpoints.py", "__init__.py", "api"], "setup": {"duration": 0.0010161999962292612, "outcome": "passed"}, "call": {"duration": 7.716128000000026, "outcome": "failed", "crash": {"path": "C:\\Projects\\building-os-platform\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/psim/search (Caused by ResponseError('too many 500 error responses'))"}, "traceback": [{"path": "test_endpoints.py", "lineno": 147, "message": ""}, {"path": "client.py", "lineno": 122, "message": "in post"}, {"path": "client.py", "lineno": 64, "message": "in make_request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 589, "message": "in request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 703, "message": "in send"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "RetryError"}], "stdout": "\n\ud83d\ude80 POST /psim/search\n\u274c Request failed: \nHTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', \nport=443): Max retries exceeded with url: /dev/psim/search (Caused by \nResponseError('too many 500 error responses'))\n", "longrepr": "urllib3.exceptions.ResponseError: too many 500 error responses\n\nThe above exception was the direct cause of the following exception:\n\nself = <requests.adapters.HTTPAdapter object at 0x000001E704969090>, request = <PreparedRequest [POST]>, stream = False, timeout = Timeout(connect=30, read=30, total=None), verify = True\ncert = None, proxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n>           resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:486: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:932: in urlopen\n    retries = retries.increment(method, url, response=response, _pool=self)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None), method = 'POST', url = '/dev/psim/search', response = <urllib3.response.HTTPResponse object at 0x000001E7051BC6D0>\nerror = None, _pool = <urllib3.connectionpool.HTTPSConnectionPool object at 0x000001E704D41D30>, _stacktrace = None\n\n    def increment(\n        self,\n        method: str | None = None,\n        url: str | None = None,\n        response: BaseHTTPResponse | None = None,\n        error: Exception | None = None,\n        _pool: ConnectionPool | None = None,\n        _stacktrace: TracebackType | None = None,\n    ) -> Self:\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or method is None or not self._is_method_retryable(method):\n                raise reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            response_redirect_location = response.get_redirect_location()\n            if response_redirect_location:\n                redirect_location = response_redirect_location\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n            reason = error or ResponseError(cause)\n>           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\nE           urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/psim/search (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:519: MaxRetryError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <api.test_endpoints.TestPSIMEndpoint object at 0x000001E70496AD50>\n\n    def test_psim_search_with_custom_query(self):\n        \"\"\"Test PSIM search with custom query\"\"\"\n        custom_query = \"python-test-user\"\n        payload = TestPayloads.psim_search(query=custom_query)\n>       response, data = client.post(\"/psim/search\", json=payload)\n\ntest_endpoints.py:147: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nclient.py:122: in post\n    return self.make_request(\"POST\", endpoint, **kwargs)\nclient.py:64: in make_request\n    response = self.session.request(\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:589: in request\n    resp = self.send(prep, **send_kwargs)\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:703: in send\n    r = adapter.send(request, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <requests.adapters.HTTPAdapter object at 0x000001E704969090>, request = <PreparedRequest [POST]>, stream = False, timeout = Timeout(connect=30, read=30, total=None), verify = True\ncert = None, proxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n            resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n    \n        except (ProtocolError, OSError) as err:\n            raise ConnectionError(err, request=request)\n    \n        except MaxRetryError as e:\n            if isinstance(e.reason, ConnectTimeoutError):\n                # TODO: Remove this in 3.0.0: see #2811\n                if not isinstance(e.reason, NewConnectionError):\n                    raise ConnectTimeout(e, request=request)\n    \n            if isinstance(e.reason, ResponseError):\n>               raise RetryError(e, request=request)\nE               requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/psim/search (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:510: RetryError"}, "teardown": {"duration": 0.0012417999969329685, "outcome": "passed", "stdout": "\n"}}, {"nodeid": "test_endpoints.py::TestCoordinatorEndpoint::test_coordinator_mission_status", "lineno": 155, "outcome": "failed", "keywords": ["test_coordinator_mission_status", "TestCoordinatorEndpoint", "test_endpoints.py", "__init__.py", "api"], "setup": {"duration": 0.0010836000001290813, "outcome": "passed"}, "call": {"duration": 9.340658900000562, "outcome": "failed", "crash": {"path": "C:\\Projects\\building-os-platform\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/coordinator/missions/test-mission-123 (Caused by ResponseError('too many 500 error responses'))"}, "traceback": [{"path": "test_endpoints.py", "lineno": 159, "message": ""}, {"path": "client.py", "lineno": 119, "message": "in get"}, {"path": "client.py", "lineno": 64, "message": "in make_request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 589, "message": "in request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 703, "message": "in send"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "RetryError"}], "stdout": "\n\ud83d\ude80 GET /coordinator/missions/test-mission-123\n\u274c Request failed: \nHTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', \nport=443): Max retries exceeded with url: \n/dev/coordinator/missions/test-mission-123 (Caused by ResponseError('too many \n500 error responses'))\n", "longrepr": "urllib3.exceptions.ResponseError: too many 500 error responses\n\nThe above exception was the direct cause of the following exception:\n\nself = <requests.adapters.HTTPAdapter object at 0x000001E704969090>, request = <PreparedRequest [GET]>, stream = False, timeout = Timeout(connect=30, read=30, total=None), verify = True\ncert = None, proxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n>           resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:486: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:932: in urlopen\n    retries = retries.increment(method, url, response=response, _pool=self)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None), method = 'GET', url = '/dev/coordinator/missions/test-mission-123'\nresponse = <urllib3.response.HTTPResponse object at 0x000001E70522B910>, error = None, _pool = <urllib3.connectionpool.HTTPSConnectionPool object at 0x000001E704D41D30>, _stacktrace = None\n\n    def increment(\n        self,\n        method: str | None = None,\n        url: str | None = None,\n        response: BaseHTTPResponse | None = None,\n        error: Exception | None = None,\n        _pool: ConnectionPool | None = None,\n        _stacktrace: TracebackType | None = None,\n    ) -> Self:\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or method is None or not self._is_method_retryable(method):\n                raise reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            response_redirect_location = response.get_redirect_location()\n            if response_redirect_location:\n                redirect_location = response_redirect_location\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n            reason = error or ResponseError(cause)\n>           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\nE           urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/coordinator/missions/test-mission-123 (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:519: MaxRetryError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <api.test_endpoints.TestCoordinatorEndpoint object at 0x000001E70496AE90>\n\n    def test_coordinator_mission_status(self):\n        \"\"\"Test coordinator mission status\"\"\"\n        mission_id = \"test-mission-123\"\n>       response, data = client.get(f\"/coordinator/missions/{mission_id}\")\n\ntest_endpoints.py:159: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nclient.py:119: in get\n    return self.make_request(\"GET\", endpoint, **kwargs)\nclient.py:64: in make_request\n    response = self.session.request(\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:589: in request\n    resp = self.send(prep, **send_kwargs)\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:703: in send\n    r = adapter.send(request, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <requests.adapters.HTTPAdapter object at 0x000001E704969090>, request = <PreparedRequest [GET]>, stream = False, timeout = Timeout(connect=30, read=30, total=None), verify = True\ncert = None, proxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n            resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n    \n        except (ProtocolError, OSError) as err:\n            raise ConnectionError(err, request=request)\n    \n        except MaxRetryError as e:\n            if isinstance(e.reason, ConnectTimeoutError):\n                # TODO: Remove this in 3.0.0: see #2811\n                if not isinstance(e.reason, NewConnectionError):\n                    raise ConnectTimeout(e, request=request)\n    \n            if isinstance(e.reason, ResponseError):\n>               raise RetryError(e, request=request)\nE               requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/coordinator/missions/test-mission-123 (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:510: RetryError"}, "teardown": {"duration": 0.0011298000026727095, "outcome": "passed", "stdout": "\n"}}, {"nodeid": "test_endpoints.py::TestCoordinatorEndpoint::test_coordinator_different_mission_id", "lineno": 166, "outcome": "failed", "keywords": ["test_coordinator_different_mission_id", "TestCoordinatorEndpoint", "test_endpoints.py", "__init__.py", "api"], "setup": {"duration": 0.0007824000058462843, "outcome": "passed"}, "call": {"duration": 8.394901699997718, "outcome": "failed", "crash": {"path": "C:\\Projects\\building-os-platform\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/coordinator/missions/python-test-1754773836 (Caused by ResponseError('too many 500 error responses'))"}, "traceback": [{"path": "test_endpoints.py", "lineno": 170, "message": ""}, {"path": "client.py", "lineno": 119, "message": "in get"}, {"path": "client.py", "lineno": 64, "message": "in make_request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 589, "message": "in request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 703, "message": "in send"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "RetryError"}], "stdout": "\n\ud83d\ude80 GET /coordinator/missions/python-test-1754773836\n\u274c Request failed: \nHTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', \nport=443): Max retries exceeded with url: \n/dev/coordinator/missions/python-test-1754773836 (Caused by ResponseError('too \nmany 500 error responses'))\n", "longrepr": "urllib3.exceptions.ResponseError: too many 500 error responses\n\nThe above exception was the direct cause of the following exception:\n\nself = <requests.adapters.HTTPAdapter object at 0x000001E704969090>, request = <PreparedRequest [GET]>, stream = False, timeout = Timeout(connect=30, read=30, total=None), verify = True\ncert = None, proxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n>           resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:486: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:932: in urlopen\n    retries = retries.increment(method, url, response=response, _pool=self)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None), method = 'GET', url = '/dev/coordinator/missions/python-test-1754773836'\nresponse = <urllib3.response.HTTPResponse object at 0x000001E7051BDED0>, error = None, _pool = <urllib3.connectionpool.HTTPSConnectionPool object at 0x000001E704D41D30>, _stacktrace = None\n\n    def increment(\n        self,\n        method: str | None = None,\n        url: str | None = None,\n        response: BaseHTTPResponse | None = None,\n        error: Exception | None = None,\n        _pool: ConnectionPool | None = None,\n        _stacktrace: TracebackType | None = None,\n    ) -> Self:\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or method is None or not self._is_method_retryable(method):\n                raise reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            response_redirect_location = response.get_redirect_location()\n            if response_redirect_location:\n                redirect_location = response_redirect_location\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n            reason = error or ResponseError(cause)\n>           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\nE           urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/coordinator/missions/python-test-1754773836 (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:519: MaxRetryError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <api.test_endpoints.TestCoordinatorEndpoint object at 0x000001E70496AFD0>\n\n    def test_coordinator_different_mission_id(self):\n        \"\"\"Test coordinator with different mission ID\"\"\"\n        mission_id = f\"python-test-{int(time.time())}\"\n>       response, data = client.get(f\"/coordinator/missions/{mission_id}\")\n\ntest_endpoints.py:170: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nclient.py:119: in get\n    return self.make_request(\"GET\", endpoint, **kwargs)\nclient.py:64: in make_request\n    response = self.session.request(\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:589: in request\n    resp = self.send(prep, **send_kwargs)\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:703: in send\n    r = adapter.send(request, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <requests.adapters.HTTPAdapter object at 0x000001E704969090>, request = <PreparedRequest [GET]>, stream = False, timeout = Timeout(connect=30, read=30, total=None), verify = True\ncert = None, proxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n            resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n    \n        except (ProtocolError, OSError) as err:\n            raise ConnectionError(err, request=request)\n    \n        except MaxRetryError as e:\n            if isinstance(e.reason, ConnectTimeoutError):\n                # TODO: Remove this in 3.0.0: see #2811\n                if not isinstance(e.reason, NewConnectionError):\n                    raise ConnectTimeout(e, request=request)\n    \n            if isinstance(e.reason, ResponseError):\n>               raise RetryError(e, request=request)\nE               requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/coordinator/missions/python-test-1754773836 (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:510: RetryError"}, "teardown": {"duration": 0.0010048999974969774, "outcome": "passed", "stdout": "\n"}}, {"nodeid": "test_endpoints.py::TestCORSHeaders::test_cors_headers_present[/health]", "lineno": 178, "outcome": "failed", "keywords": ["test_cors_headers_present[/health]", "parametrize", "pytestmark", "/health", "TestCORSHeaders", "test_endpoints.py", "__init__.py", "api"], "setup": {"duration": 0.0010873999999603257, "outcome": "passed"}, "call": {"duration": 0.2127522999944631, "outcome": "failed", "crash": {"path": "c:\\Projects\\building-os-platform\\tests\\api\\test_endpoints.py", "lineno": 215, "message": "AssertionError: No CORS headers found in response for /health\nassert False"}, "traceback": [{"path": "test_endpoints.py", "lineno": 215, "message": "AssertionError"}], "stdout": "\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 210.33ms | \ud83d\udce6 Size: 60 bytes\n", "longrepr": "self = <api.test_endpoints.TestCORSHeaders object at 0x000001E70496B390>, endpoint = '/health'\n\n    @pytest.mark.parametrize(\n        \"endpoint\",\n        [\n            \"/health\",\n            \"/director\",\n            \"/persona\",\n            \"/elevator/call\",\n            \"/psim/search\",\n            \"/coordinator/missions/test-123\",\n        ],\n    )\n    def test_cors_headers_present(self, endpoint):\n        \"\"\"Test that CORS headers are present\"\"\"\n        method = (\n            \"POST\"\n            if endpoint in [\"/persona\", \"/elevator/call\", \"/psim/search\"]\n            else \"GET\"\n        )\n    \n        if method == \"POST\":\n            payload = {\"test\": \"data\"}\n            response, _ = client.post(endpoint, json=payload)\n        else:\n            response, _ = client.get(endpoint)\n    \n        # Check for CORS headers (they might be case-insensitive)\n        headers_lower = {k.lower(): v for k, v in response.headers.items()}\n    \n        # At least one CORS header should be present\n        cors_headers = [\n            \"access-control-allow-origin\",\n            \"access-control-allow-methods\",\n            \"access-control-allow-headers\",\n        ]\n    \n        has_cors = any(header in headers_lower for header in cors_headers)\n>       assert has_cors, f\"No CORS headers found in response for {endpoint}\"\nE       AssertionError: No CORS headers found in response for /health\nE       assert False\n\ntest_endpoints.py:215: AssertionError"}, "teardown": {"duration": 0.0009253999960492365, "outcome": "passed", "stdout": "\n"}}, {"nodeid": "test_endpoints.py::TestCORSHeaders::test_cors_headers_present[/director]", "lineno": 178, "outcome": "failed", "keywords": ["test_cors_headers_present[/director]", "parametrize", "pytestmark", "/director", "TestCORSHeaders", "test_endpoints.py", "__init__.py", "api"], "setup": {"duration": 0.000588999995670747, "outcome": "passed"}, "call": {"duration": 8.737217400004738, "outcome": "failed", "crash": {"path": "C:\\Projects\\building-os-platform\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/director (Caused by ResponseError('too many 500 error responses'))"}, "traceback": [{"path": "test_endpoints.py", "lineno": 202, "message": ""}, {"path": "client.py", "lineno": 119, "message": "in get"}, {"path": "client.py", "lineno": 64, "message": "in make_request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 589, "message": "in request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 703, "message": "in send"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "RetryError"}], "stdout": "\n\ud83d\ude80 GET /director\n\u274c Request failed: \nHTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', \nport=443): Max retries exceeded with url: /dev/director (Caused by \nResponseError('too many 500 error responses'))\n", "longrepr": "urllib3.exceptions.ResponseError: too many 500 error responses\n\nThe above exception was the direct cause of the following exception:\n\nself = <requests.adapters.HTTPAdapter object at 0x000001E704969090>, request = <PreparedRequest [GET]>, stream = False, timeout = Timeout(connect=30, read=30, total=None), verify = True\ncert = None, proxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n>           resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:486: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:932: in urlopen\n    retries = retries.increment(method, url, response=response, _pool=self)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None), method = 'GET', url = '/dev/director', response = <urllib3.response.HTTPResponse object at 0x000001E70523A260>\nerror = None, _pool = <urllib3.connectionpool.HTTPSConnectionPool object at 0x000001E704D41D30>, _stacktrace = None\n\n    def increment(\n        self,\n        method: str | None = None,\n        url: str | None = None,\n        response: BaseHTTPResponse | None = None,\n        error: Exception | None = None,\n        _pool: ConnectionPool | None = None,\n        _stacktrace: TracebackType | None = None,\n    ) -> Self:\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or method is None or not self._is_method_retryable(method):\n                raise reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            response_redirect_location = response.get_redirect_location()\n            if response_redirect_location:\n                redirect_location = response_redirect_location\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n            reason = error or ResponseError(cause)\n>           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\nE           urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/director (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:519: MaxRetryError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <api.test_endpoints.TestCORSHeaders object at 0x000001E70496B4D0>, endpoint = '/director'\n\n    @pytest.mark.parametrize(\n        \"endpoint\",\n        [\n            \"/health\",\n            \"/director\",\n            \"/persona\",\n            \"/elevator/call\",\n            \"/psim/search\",\n            \"/coordinator/missions/test-123\",\n        ],\n    )\n    def test_cors_headers_present(self, endpoint):\n        \"\"\"Test that CORS headers are present\"\"\"\n        method = (\n            \"POST\"\n            if endpoint in [\"/persona\", \"/elevator/call\", \"/psim/search\"]\n            else \"GET\"\n        )\n    \n        if method == \"POST\":\n            payload = {\"test\": \"data\"}\n            response, _ = client.post(endpoint, json=payload)\n        else:\n>           response, _ = client.get(endpoint)\n\ntest_endpoints.py:202: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nclient.py:119: in get\n    return self.make_request(\"GET\", endpoint, **kwargs)\nclient.py:64: in make_request\n    response = self.session.request(\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:589: in request\n    resp = self.send(prep, **send_kwargs)\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:703: in send\n    r = adapter.send(request, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <requests.adapters.HTTPAdapter object at 0x000001E704969090>, request = <PreparedRequest [GET]>, stream = False, timeout = Timeout(connect=30, read=30, total=None), verify = True\ncert = None, proxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n            resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n    \n        except (ProtocolError, OSError) as err:\n            raise ConnectionError(err, request=request)\n    \n        except MaxRetryError as e:\n            if isinstance(e.reason, ConnectTimeoutError):\n                # TODO: Remove this in 3.0.0: see #2811\n                if not isinstance(e.reason, NewConnectionError):\n                    raise ConnectTimeout(e, request=request)\n    \n            if isinstance(e.reason, ResponseError):\n>               raise RetryError(e, request=request)\nE               requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/director (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:510: RetryError"}, "teardown": {"duration": 0.0011039999953936785, "outcome": "passed", "stdout": "\n"}}, {"nodeid": "test_endpoints.py::TestCORSHeaders::test_cors_headers_present[/persona]", "lineno": 178, "outcome": "failed", "keywords": ["test_cors_headers_present[/persona]", "parametrize", "pytestmark", "/persona", "TestCORSHeaders", "test_endpoints.py", "__init__.py", "api"], "setup": {"duration": 0.0011301999984425493, "outcome": "passed"}, "call": {"duration": 8.313369700001203, "outcome": "failed", "crash": {"path": "C:\\Projects\\building-os-platform\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/persona (Caused by ResponseError('too many 500 error responses'))"}, "traceback": [{"path": "test_endpoints.py", "lineno": 200, "message": ""}, {"path": "client.py", "lineno": 122, "message": "in post"}, {"path": "client.py", "lineno": 64, "message": "in make_request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 589, "message": "in request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 703, "message": "in send"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "RetryError"}], "stdout": "\n\ud83d\ude80 POST /persona\n\u274c Request failed: \nHTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', \nport=443): Max retries exceeded with url: /dev/persona (Caused by \nResponseError('too many 500 error responses'))\n", "longrepr": "urllib3.exceptions.ResponseError: too many 500 error responses\n\nThe above exception was the direct cause of the following exception:\n\nself = <requests.adapters.HTTPAdapter object at 0x000001E704969090>, request = <PreparedRequest [POST]>, stream = False, timeout = Timeout(connect=30, read=30, total=None), verify = True\ncert = None, proxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n>           resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:486: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:932: in urlopen\n    retries = retries.increment(method, url, response=response, _pool=self)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None), method = 'POST', url = '/dev/persona', response = <urllib3.response.HTTPResponse object at 0x000001E70522B8B0>\nerror = None, _pool = <urllib3.connectionpool.HTTPSConnectionPool object at 0x000001E704D41D30>, _stacktrace = None\n\n    def increment(\n        self,\n        method: str | None = None,\n        url: str | None = None,\n        response: BaseHTTPResponse | None = None,\n        error: Exception | None = None,\n        _pool: ConnectionPool | None = None,\n        _stacktrace: TracebackType | None = None,\n    ) -> Self:\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or method is None or not self._is_method_retryable(method):\n                raise reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            response_redirect_location = response.get_redirect_location()\n            if response_redirect_location:\n                redirect_location = response_redirect_location\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n            reason = error or ResponseError(cause)\n>           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\nE           urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/persona (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:519: MaxRetryError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <api.test_endpoints.TestCORSHeaders object at 0x000001E70493B5C0>, endpoint = '/persona'\n\n    @pytest.mark.parametrize(\n        \"endpoint\",\n        [\n            \"/health\",\n            \"/director\",\n            \"/persona\",\n            \"/elevator/call\",\n            \"/psim/search\",\n            \"/coordinator/missions/test-123\",\n        ],\n    )\n    def test_cors_headers_present(self, endpoint):\n        \"\"\"Test that CORS headers are present\"\"\"\n        method = (\n            \"POST\"\n            if endpoint in [\"/persona\", \"/elevator/call\", \"/psim/search\"]\n            else \"GET\"\n        )\n    \n        if method == \"POST\":\n            payload = {\"test\": \"data\"}\n>           response, _ = client.post(endpoint, json=payload)\n\ntest_endpoints.py:200: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nclient.py:122: in post\n    return self.make_request(\"POST\", endpoint, **kwargs)\nclient.py:64: in make_request\n    response = self.session.request(\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:589: in request\n    resp = self.send(prep, **send_kwargs)\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:703: in send\n    r = adapter.send(request, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <requests.adapters.HTTPAdapter object at 0x000001E704969090>, request = <PreparedRequest [POST]>, stream = False, timeout = Timeout(connect=30, read=30, total=None), verify = True\ncert = None, proxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n            resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n    \n        except (ProtocolError, OSError) as err:\n            raise ConnectionError(err, request=request)\n    \n        except MaxRetryError as e:\n            if isinstance(e.reason, ConnectTimeoutError):\n                # TODO: Remove this in 3.0.0: see #2811\n                if not isinstance(e.reason, NewConnectionError):\n                    raise ConnectTimeout(e, request=request)\n    \n            if isinstance(e.reason, ResponseError):\n>               raise RetryError(e, request=request)\nE               requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/persona (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:510: RetryError"}, "teardown": {"duration": 0.0011472999976831488, "outcome": "passed", "stdout": "\n"}}, {"nodeid": "test_endpoints.py::TestCORSHeaders::test_cors_headers_present[/elevator/call]", "lineno": 178, "outcome": "failed", "keywords": ["test_cors_headers_present[/elevator/call]", "parametrize", "pytestmark", "/elevator/call", "TestCORSHeaders", "test_endpoints.py", "__init__.py", "api"], "setup": {"duration": 0.0015733999971416779, "outcome": "passed"}, "call": {"duration": 7.6940480999983265, "outcome": "failed", "crash": {"path": "C:\\Projects\\building-os-platform\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/elevator/call (Caused by ResponseError('too many 500 error responses'))"}, "traceback": [{"path": "test_endpoints.py", "lineno": 200, "message": ""}, {"path": "client.py", "lineno": 122, "message": "in post"}, {"path": "client.py", "lineno": 64, "message": "in make_request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 589, "message": "in request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 703, "message": "in send"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "RetryError"}], "stdout": "\n\ud83d\ude80 POST /elevator/call\n\u274c Request failed: \nHTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', \nport=443): Max retries exceeded with url: /dev/elevator/call (Caused by \nResponseError('too many 500 error responses'))\n", "longrepr": "urllib3.exceptions.ResponseError: too many 500 error responses\n\nThe above exception was the direct cause of the following exception:\n\nself = <requests.adapters.HTTPAdapter object at 0x000001E704969090>, request = <PreparedRequest [POST]>, stream = False, timeout = Timeout(connect=30, read=30, total=None), verify = True\ncert = None, proxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n>           resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:486: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:932: in urlopen\n    retries = retries.increment(method, url, response=response, _pool=self)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None), method = 'POST', url = '/dev/elevator/call', response = <urllib3.response.HTTPResponse object at 0x000001E70522B0D0>\nerror = None, _pool = <urllib3.connectionpool.HTTPSConnectionPool object at 0x000001E704D41D30>, _stacktrace = None\n\n    def increment(\n        self,\n        method: str | None = None,\n        url: str | None = None,\n        response: BaseHTTPResponse | None = None,\n        error: Exception | None = None,\n        _pool: ConnectionPool | None = None,\n        _stacktrace: TracebackType | None = None,\n    ) -> Self:\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or method is None or not self._is_method_retryable(method):\n                raise reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            response_redirect_location = response.get_redirect_location()\n            if response_redirect_location:\n                redirect_location = response_redirect_location\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n            reason = error or ResponseError(cause)\n>           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\nE           urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/elevator/call (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:519: MaxRetryError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <api.test_endpoints.TestCORSHeaders object at 0x000001E70493B6F0>, endpoint = '/elevator/call'\n\n    @pytest.mark.parametrize(\n        \"endpoint\",\n        [\n            \"/health\",\n            \"/director\",\n            \"/persona\",\n            \"/elevator/call\",\n            \"/psim/search\",\n            \"/coordinator/missions/test-123\",\n        ],\n    )\n    def test_cors_headers_present(self, endpoint):\n        \"\"\"Test that CORS headers are present\"\"\"\n        method = (\n            \"POST\"\n            if endpoint in [\"/persona\", \"/elevator/call\", \"/psim/search\"]\n            else \"GET\"\n        )\n    \n        if method == \"POST\":\n            payload = {\"test\": \"data\"}\n>           response, _ = client.post(endpoint, json=payload)\n\ntest_endpoints.py:200: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nclient.py:122: in post\n    return self.make_request(\"POST\", endpoint, **kwargs)\nclient.py:64: in make_request\n    response = self.session.request(\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:589: in request\n    resp = self.send(prep, **send_kwargs)\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:703: in send\n    r = adapter.send(request, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <requests.adapters.HTTPAdapter object at 0x000001E704969090>, request = <PreparedRequest [POST]>, stream = False, timeout = Timeout(connect=30, read=30, total=None), verify = True\ncert = None, proxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n            resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n    \n        except (ProtocolError, OSError) as err:\n            raise ConnectionError(err, request=request)\n    \n        except MaxRetryError as e:\n            if isinstance(e.reason, ConnectTimeoutError):\n                # TODO: Remove this in 3.0.0: see #2811\n                if not isinstance(e.reason, NewConnectionError):\n                    raise ConnectTimeout(e, request=request)\n    \n            if isinstance(e.reason, ResponseError):\n>               raise RetryError(e, request=request)\nE               requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/elevator/call (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:510: RetryError"}, "teardown": {"duration": 0.001166699999885168, "outcome": "passed", "stdout": "\n"}}, {"nodeid": "test_endpoints.py::TestCORSHeaders::test_cors_headers_present[/psim/search]", "lineno": 178, "outcome": "failed", "keywords": ["test_cors_headers_present[/psim/search]", "parametrize", "pytestmark", "/psim/search", "TestCORSHeaders", "test_endpoints.py", "__init__.py", "api"], "setup": {"duration": 0.0009328000014647841, "outcome": "passed"}, "call": {"duration": 7.796477400006552, "outcome": "failed", "crash": {"path": "C:\\Projects\\building-os-platform\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/psim/search (Caused by ResponseError('too many 500 error responses'))"}, "traceback": [{"path": "test_endpoints.py", "lineno": 200, "message": ""}, {"path": "client.py", "lineno": 122, "message": "in post"}, {"path": "client.py", "lineno": 64, "message": "in make_request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 589, "message": "in request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 703, "message": "in send"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "RetryError"}], "stdout": "\n\ud83d\ude80 POST /psim/search\n\u274c Request failed: \nHTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', \nport=443): Max retries exceeded with url: /dev/psim/search (Caused by \nResponseError('too many 500 error responses'))\n", "longrepr": "urllib3.exceptions.ResponseError: too many 500 error responses\n\nThe above exception was the direct cause of the following exception:\n\nself = <requests.adapters.HTTPAdapter object at 0x000001E704969090>, request = <PreparedRequest [POST]>, stream = False, timeout = Timeout(connect=30, read=30, total=None), verify = True\ncert = None, proxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n>           resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:486: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:932: in urlopen\n    retries = retries.increment(method, url, response=response, _pool=self)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None), method = 'POST', url = '/dev/psim/search', response = <urllib3.response.HTTPResponse object at 0x000001E705239960>\nerror = None, _pool = <urllib3.connectionpool.HTTPSConnectionPool object at 0x000001E704D41D30>, _stacktrace = None\n\n    def increment(\n        self,\n        method: str | None = None,\n        url: str | None = None,\n        response: BaseHTTPResponse | None = None,\n        error: Exception | None = None,\n        _pool: ConnectionPool | None = None,\n        _stacktrace: TracebackType | None = None,\n    ) -> Self:\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or method is None or not self._is_method_retryable(method):\n                raise reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            response_redirect_location = response.get_redirect_location()\n            if response_redirect_location:\n                redirect_location = response_redirect_location\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n            reason = error or ResponseError(cause)\n>           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\nE           urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/psim/search (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:519: MaxRetryError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <api.test_endpoints.TestCORSHeaders object at 0x000001E704A20290>, endpoint = '/psim/search'\n\n    @pytest.mark.parametrize(\n        \"endpoint\",\n        [\n            \"/health\",\n            \"/director\",\n            \"/persona\",\n            \"/elevator/call\",\n            \"/psim/search\",\n            \"/coordinator/missions/test-123\",\n        ],\n    )\n    def test_cors_headers_present(self, endpoint):\n        \"\"\"Test that CORS headers are present\"\"\"\n        method = (\n            \"POST\"\n            if endpoint in [\"/persona\", \"/elevator/call\", \"/psim/search\"]\n            else \"GET\"\n        )\n    \n        if method == \"POST\":\n            payload = {\"test\": \"data\"}\n>           response, _ = client.post(endpoint, json=payload)\n\ntest_endpoints.py:200: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nclient.py:122: in post\n    return self.make_request(\"POST\", endpoint, **kwargs)\nclient.py:64: in make_request\n    response = self.session.request(\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:589: in request\n    resp = self.send(prep, **send_kwargs)\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:703: in send\n    r = adapter.send(request, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <requests.adapters.HTTPAdapter object at 0x000001E704969090>, request = <PreparedRequest [POST]>, stream = False, timeout = Timeout(connect=30, read=30, total=None), verify = True\ncert = None, proxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n            resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n    \n        except (ProtocolError, OSError) as err:\n            raise ConnectionError(err, request=request)\n    \n        except MaxRetryError as e:\n            if isinstance(e.reason, ConnectTimeoutError):\n                # TODO: Remove this in 3.0.0: see #2811\n                if not isinstance(e.reason, NewConnectionError):\n                    raise ConnectTimeout(e, request=request)\n    \n            if isinstance(e.reason, ResponseError):\n>               raise RetryError(e, request=request)\nE               requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/psim/search (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:510: RetryError"}, "teardown": {"duration": 0.0010924000016530044, "outcome": "passed", "stdout": "\n"}}, {"nodeid": "test_endpoints.py::TestCORSHeaders::test_cors_headers_present[/coordinator/missions/test-123]", "lineno": 178, "outcome": "failed", "keywords": ["test_cors_headers_present[/coordinator/missions/test-123]", "parametrize", "pytestmark", "/coordinator/missions/test-123", "TestCORSHeaders", "test_endpoints.py", "__init__.py", "api"], "setup": {"duration": 0.0009051999950315803, "outcome": "passed"}, "call": {"duration": 8.343257999993511, "outcome": "failed", "crash": {"path": "C:\\Projects\\building-os-platform\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/coordinator/missions/test-123 (Caused by ResponseError('too many 500 error responses'))"}, "traceback": [{"path": "test_endpoints.py", "lineno": 202, "message": ""}, {"path": "client.py", "lineno": 119, "message": "in get"}, {"path": "client.py", "lineno": 64, "message": "in make_request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 589, "message": "in request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 703, "message": "in send"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "RetryError"}], "stdout": "\n\ud83d\ude80 GET /coordinator/missions/test-123\n\u274c Request failed: \nHTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', \nport=443): Max retries exceeded with url: /dev/coordinator/missions/test-123 \n(Caused by ResponseError('too many 500 error responses'))\n", "longrepr": "urllib3.exceptions.ResponseError: too many 500 error responses\n\nThe above exception was the direct cause of the following exception:\n\nself = <requests.adapters.HTTPAdapter object at 0x000001E704969090>, request = <PreparedRequest [GET]>, stream = False, timeout = Timeout(connect=30, read=30, total=None), verify = True\ncert = None, proxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n>           resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:486: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:932: in urlopen\n    retries = retries.increment(method, url, response=response, _pool=self)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None), method = 'GET', url = '/dev/coordinator/missions/test-123'\nresponse = <urllib3.response.HTTPResponse object at 0x000001E704E0A7A0>, error = None, _pool = <urllib3.connectionpool.HTTPSConnectionPool object at 0x000001E704D41D30>, _stacktrace = None\n\n    def increment(\n        self,\n        method: str | None = None,\n        url: str | None = None,\n        response: BaseHTTPResponse | None = None,\n        error: Exception | None = None,\n        _pool: ConnectionPool | None = None,\n        _stacktrace: TracebackType | None = None,\n    ) -> Self:\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or method is None or not self._is_method_retryable(method):\n                raise reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            response_redirect_location = response.get_redirect_location()\n            if response_redirect_location:\n                redirect_location = response_redirect_location\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n            reason = error or ResponseError(cause)\n>           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\nE           urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/coordinator/missions/test-123 (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:519: MaxRetryError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <api.test_endpoints.TestCORSHeaders object at 0x000001E7049D8AF0>, endpoint = '/coordinator/missions/test-123'\n\n    @pytest.mark.parametrize(\n        \"endpoint\",\n        [\n            \"/health\",\n            \"/director\",\n            \"/persona\",\n            \"/elevator/call\",\n            \"/psim/search\",\n            \"/coordinator/missions/test-123\",\n        ],\n    )\n    def test_cors_headers_present(self, endpoint):\n        \"\"\"Test that CORS headers are present\"\"\"\n        method = (\n            \"POST\"\n            if endpoint in [\"/persona\", \"/elevator/call\", \"/psim/search\"]\n            else \"GET\"\n        )\n    \n        if method == \"POST\":\n            payload = {\"test\": \"data\"}\n            response, _ = client.post(endpoint, json=payload)\n        else:\n>           response, _ = client.get(endpoint)\n\ntest_endpoints.py:202: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nclient.py:119: in get\n    return self.make_request(\"GET\", endpoint, **kwargs)\nclient.py:64: in make_request\n    response = self.session.request(\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:589: in request\n    resp = self.send(prep, **send_kwargs)\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:703: in send\n    r = adapter.send(request, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <requests.adapters.HTTPAdapter object at 0x000001E704969090>, request = <PreparedRequest [GET]>, stream = False, timeout = Timeout(connect=30, read=30, total=None), verify = True\ncert = None, proxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n            resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n    \n        except (ProtocolError, OSError) as err:\n            raise ConnectionError(err, request=request)\n    \n        except MaxRetryError as e:\n            if isinstance(e.reason, ConnectTimeoutError):\n                # TODO: Remove this in 3.0.0: see #2811\n                if not isinstance(e.reason, NewConnectionError):\n                    raise ConnectTimeout(e, request=request)\n    \n            if isinstance(e.reason, ResponseError):\n>               raise RetryError(e, request=request)\nE               requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/coordinator/missions/test-123 (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:510: RetryError"}, "teardown": {"duration": 0.0010808000006363727, "outcome": "passed", "stdout": "\n"}}, {"nodeid": "test_endpoints.py::TestErrorHandling::test_invalid_endpoint", "lineno": 220, "outcome": "passed", "keywords": ["test_invalid_endpoint", "TestErrorHandling", "test_endpoints.py", "__init__.py", "api"], "setup": {"duration": 0.0008757999967201613, "outcome": "passed"}, "call": {"duration": 0.1916960000016843, "outcome": "passed", "stdout": "\n\ud83d\ude80 GET /invalid-endpoint\n\ud83d\udcca Status: 404 | \u23f1\ufe0f  Time: 189.11ms | \ud83d\udce6 Size: 23 bytes\n"}, "teardown": {"duration": 0.001079499998013489, "outcome": "passed", "stdout": "\n"}}, {"nodeid": "test_endpoints.py::TestErrorHandling::test_invalid_method", "lineno": 225, "outcome": "passed", "keywords": ["test_invalid_method", "TestErrorHandling", "test_endpoints.py", "__init__.py", "api"], "setup": {"duration": 0.0005300999982864596, "outcome": "passed"}, "call": {"duration": 0.17131370000424795, "outcome": "passed", "stdout": "\n\ud83d\ude80 DELETE /health\n\ud83d\udcca Status: 404 | \u23f1\ufe0f  Time: 169.06ms | \ud83d\udce6 Size: 23 bytes\n"}, "teardown": {"duration": 0.0008573000013711862, "outcome": "passed", "stdout": "\n"}}, {"nodeid": "test_endpoints.py::TestErrorHandling::test_malformed_json", "lineno": 235, "outcome": "passed", "keywords": ["test_malformed_json", "TestErrorHandling", "test_endpoints.py", "__init__.py", "api"], "setup": {"duration": 0.0004763000033563003, "outcome": "passed"}, "call": {"duration": 8.446436999998696, "outcome": "passed"}, "teardown": {"duration": 0.00090970000019297, "outcome": "passed", "stdout": "\n"}}, {"nodeid": "test_performance.py::TestPerformance::test_response_time_under_threshold", "lineno": 18, "outcome": "failed", "keywords": ["test_response_time_under_threshold", "TestPerformance", "test_performance.py", "__init__.py", "api"], "setup": {"duration": 0.00038439999480033293, "outcome": "passed"}, "call": {"duration": 8.686695399999735, "outcome": "failed", "crash": {"path": "C:\\Projects\\building-os-platform\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/director (Caused by ResponseError('too many 500 error responses'))"}, "traceback": [{"path": "test_performance.py", "lineno": 35, "message": ""}, {"path": "client.py", "lineno": 119, "message": "in get"}, {"path": "client.py", "lineno": 64, "message": "in make_request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 589, "message": "in request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 703, "message": "in send"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "RetryError"}], "stdout": "\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 195.88ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /director\n\u274c Request failed: \nHTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', \nport=443): Max retries exceeded with url: /dev/director (Caused by \nResponseError('too many 500 error responses'))\n", "longrepr": "urllib3.exceptions.ResponseError: too many 500 error responses\n\nThe above exception was the direct cause of the following exception:\n\nself = <requests.adapters.HTTPAdapter object at 0x000001E704969090>, request = <PreparedRequest [GET]>, stream = False, timeout = Timeout(connect=30, read=30, total=None), verify = True\ncert = None, proxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n>           resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:486: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:932: in urlopen\n    retries = retries.increment(method, url, response=response, _pool=self)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None), method = 'GET', url = '/dev/director', response = <urllib3.response.HTTPResponse object at 0x000001E705183460>\nerror = None, _pool = <urllib3.connectionpool.HTTPSConnectionPool object at 0x000001E704D41D30>, _stacktrace = None\n\n    def increment(\n        self,\n        method: str | None = None,\n        url: str | None = None,\n        response: BaseHTTPResponse | None = None,\n        error: Exception | None = None,\n        _pool: ConnectionPool | None = None,\n        _stacktrace: TracebackType | None = None,\n    ) -> Self:\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or method is None or not self._is_method_retryable(method):\n                raise reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            response_redirect_location = response.get_redirect_location()\n            if response_redirect_location:\n                redirect_location = response_redirect_location\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n            reason = error or ResponseError(cause)\n>           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\nE           urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/director (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:519: MaxRetryError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <api.test_performance.TestPerformance object at 0x000001E704BE7ED0>\n\n    def test_response_time_under_threshold(self):\n        \"\"\"Test that all endpoints respond within acceptable time\"\"\"\n        endpoints = [\n            (\"/health\", \"GET\", None),\n            (\"/director\", \"GET\", None),\n            (\"/persona\", \"POST\", {\"user_id\": \"perf-test\", \"message\": \"test\"}),\n            (\"/psim/search\", \"POST\", {\"action\": \"search_person\", \"query\": \"test\"}),\n            (\"/coordinator/missions/perf-test-123\", \"GET\", None),\n        ]\n    \n        threshold_ms = 3000  # 3 seconds\n    \n        for endpoint, method, payload in endpoints:\n            start_time = time.time()\n    \n            if method == \"GET\":\n>               response, data = client.get(endpoint)\n\ntest_performance.py:35: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nclient.py:119: in get\n    return self.make_request(\"GET\", endpoint, **kwargs)\nclient.py:64: in make_request\n    response = self.session.request(\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:589: in request\n    resp = self.send(prep, **send_kwargs)\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:703: in send\n    r = adapter.send(request, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <requests.adapters.HTTPAdapter object at 0x000001E704969090>, request = <PreparedRequest [GET]>, stream = False, timeout = Timeout(connect=30, read=30, total=None), verify = True\ncert = None, proxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n            resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n    \n        except (ProtocolError, OSError) as err:\n            raise ConnectionError(err, request=request)\n    \n        except MaxRetryError as e:\n            if isinstance(e.reason, ConnectTimeoutError):\n                # TODO: Remove this in 3.0.0: see #2811\n                if not isinstance(e.reason, NewConnectionError):\n                    raise ConnectTimeout(e, request=request)\n    \n            if isinstance(e.reason, ResponseError):\n>               raise RetryError(e, request=request)\nE               requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/director (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:510: RetryError"}, "teardown": {"duration": 0.0004993999973521568, "outcome": "passed"}}, {"nodeid": "test_performance.py::TestPerformance::test_concurrent_health_checks", "lineno": 45, "outcome": "passed", "keywords": ["test_concurrent_health_checks", "TestPerformance", "test_performance.py", "__init__.py", "api"], "setup": {"duration": 0.001772000003256835, "outcome": "passed"}, "call": {"duration": 1.9021301999964635, "outcome": "passed", "stdout": "\n\ud83d\ude80 GET /health\n\n\ud83d\ude80 GET /health\n\n\ud83d\ude80 GET /health\n\n\ud83d\ude80 GET /health\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 205.46ms | \ud83d\udce6 Size: 60 bytes\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 1705.34ms | \ud83d\udce6 Size: 60 bytes\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 1841.45ms | \ud83d\udce6 Size: 60 bytes\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 1856.50ms | \ud83d\udce6 Size: 60 bytes\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 1897.37ms | \ud83d\udce6 Size: 60 bytes\n"}, "teardown": {"duration": 0.0004654000003938563, "outcome": "passed"}}, {"nodeid": "test_performance.py::TestLoadTesting::test_sustained_load_health_endpoint", "lineno": 72, "outcome": "passed", "keywords": ["test_sustained_load_health_endpoint", "slow", "pytestmark", "TestLoadTesting", "test_performance.py", "__init__.py", "api"], "setup": {"duration": 0.0005443999980343506, "outcome": "passed"}, "call": {"duration": 15.522036800000933, "outcome": "passed", "stdout": "\n\ud83d\udd25 Running sustained load test...\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 208.38ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 196.04ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 841.07ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 188.78ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 195.29ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 195.93ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 191.06ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 195.59ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 189.74ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 201.68ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 215.63ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 302.97ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 943.74ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 201.71ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 215.40ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 189.56ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 712.23ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 198.32ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 194.62ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 189.63ms | \ud83d\udce6 Size: 60 bytes\n  Making 20 requests... 0:00:15\n\u2705 Success rate: 100.0% (20/20)\n\u23f1\ufe0f  Avg response: 300.15ms\n\ud83d\udc0c Max response: 945.43ms\n\u26a1 Min response: 190.54ms\n"}, "teardown": {"duration": 0.0004809000020031817, "outcome": "passed"}}, {"nodeid": "test_performance.py::TestStressScenarios::test_large_payload_persona", "lineno": 149, "outcome": "failed", "keywords": ["test_large_payload_persona", "TestStressScenarios", "test_performance.py", "__init__.py", "api"], "setup": {"duration": 0.0004364000051282346, "outcome": "passed"}, "call": {"duration": 10.676674900001672, "outcome": "failed", "crash": {"path": "C:\\Projects\\building-os-platform\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/persona (Caused by ResponseError('too many 500 error responses'))"}, "traceback": [{"path": "test_performance.py", "lineno": 155, "message": ""}, {"path": "client.py", "lineno": 122, "message": "in post"}, {"path": "client.py", "lineno": 64, "message": "in make_request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 589, "message": "in request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 703, "message": "in send"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "RetryError"}], "stdout": "\n\ud83d\ude80 POST /persona\n\u274c Request failed: \nHTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', \nport=443): Max retries exceeded with url: /dev/persona (Caused by \nResponseError('too many 500 error responses'))\n", "longrepr": "urllib3.exceptions.ResponseError: too many 500 error responses\n\nThe above exception was the direct cause of the following exception:\n\nself = <requests.adapters.HTTPAdapter object at 0x000001E704969090>, request = <PreparedRequest [POST]>, stream = False, timeout = Timeout(connect=30, read=30, total=None), verify = True\ncert = None, proxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n>           resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:486: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:932: in urlopen\n    retries = retries.increment(method, url, response=response, _pool=self)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None), method = 'POST', url = '/dev/persona', response = <urllib3.response.HTTPResponse object at 0x000001E70521C910>\nerror = None, _pool = <urllib3.connectionpool.HTTPSConnectionPool object at 0x000001E704D41D30>, _stacktrace = None\n\n    def increment(\n        self,\n        method: str | None = None,\n        url: str | None = None,\n        response: BaseHTTPResponse | None = None,\n        error: Exception | None = None,\n        _pool: ConnectionPool | None = None,\n        _stacktrace: TracebackType | None = None,\n    ) -> Self:\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or method is None or not self._is_method_retryable(method):\n                raise reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            response_redirect_location = response.get_redirect_location()\n            if response_redirect_location:\n                redirect_location = response_redirect_location\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n            reason = error or ResponseError(cause)\n>           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\nE           urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/persona (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:519: MaxRetryError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <api.test_performance.TestStressScenarios object at 0x000001E7051B82D0>\n\n    def test_large_payload_persona(self):\n        \"\"\"Test persona endpoint with large message\"\"\"\n        large_message = \"x\" * 10000  # 10KB message\n        payload = {\"user_id\": \"stress-test-user\", \"message\": large_message}\n    \n>       response, data = client.post(\"/persona\", json=payload)\n\ntest_performance.py:155: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nclient.py:122: in post\n    return self.make_request(\"POST\", endpoint, **kwargs)\nclient.py:64: in make_request\n    response = self.session.request(\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:589: in request\n    resp = self.send(prep, **send_kwargs)\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:703: in send\n    r = adapter.send(request, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <requests.adapters.HTTPAdapter object at 0x000001E704969090>, request = <PreparedRequest [POST]>, stream = False, timeout = Timeout(connect=30, read=30, total=None), verify = True\ncert = None, proxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n            resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n    \n        except (ProtocolError, OSError) as err:\n            raise ConnectionError(err, request=request)\n    \n        except MaxRetryError as e:\n            if isinstance(e.reason, ConnectTimeoutError):\n                # TODO: Remove this in 3.0.0: see #2811\n                if not isinstance(e.reason, NewConnectionError):\n                    raise ConnectTimeout(e, request=request)\n    \n            if isinstance(e.reason, ResponseError):\n>               raise RetryError(e, request=request)\nE               requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/persona (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:510: RetryError"}, "teardown": {"duration": 0.0004735000038635917, "outcome": "passed"}}, {"nodeid": "test_performance.py::TestStressScenarios::test_rapid_successive_requests", "lineno": 163, "outcome": "passed", "keywords": ["test_rapid_successive_requests", "TestStressScenarios", "test_performance.py", "__init__.py", "api"], "setup": {"duration": 0.0003663000024971552, "outcome": "passed"}, "call": {"duration": 2.556430399999954, "outcome": "passed", "stdout": "\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 199.88ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 192.39ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 200.09ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 195.44ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 201.54ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 360.98ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 303.71ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 192.32ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 197.37ms | \ud83d\udce6 Size: 60 bytes\n\n\ud83d\ude80 GET /health\n\ud83d\udcca Status: 200 | \u23f1\ufe0f  Time: 496.08ms | \ud83d\udce6 Size: 60 bytes\n\ud83d\ude80 Rapid requests: 10 in 2.55s\n\u2705 Success rate: 100.0%\n"}, "teardown": {"duration": 0.000436399997852277, "outcome": "passed"}}, {"nodeid": "test_performance.py::TestStressScenarios::test_special_characters_in_requests", "lineno": 189, "outcome": "failed", "keywords": ["test_special_characters_in_requests", "TestStressScenarios", "test_performance.py", "__init__.py", "api"], "setup": {"duration": 0.0005224999986239709, "outcome": "passed"}, "call": {"duration": 8.38783759999933, "outcome": "failed", "crash": {"path": "C:\\Projects\\building-os-platform\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/persona (Caused by ResponseError('too many 500 error responses'))"}, "traceback": [{"path": "test_performance.py", "lineno": 205, "message": ""}, {"path": "client.py", "lineno": 122, "message": "in post"}, {"path": "client.py", "lineno": 64, "message": "in make_request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 589, "message": "in request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 703, "message": "in send"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "RetryError"}], "stdout": "\n\ud83d\ude80 POST /persona\n\u274c Request failed: \nHTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', \nport=443): Max retries exceeded with url: /dev/persona (Caused by \nResponseError('too many 500 error responses'))\n", "longrepr": "urllib3.exceptions.ResponseError: too many 500 error responses\n\nThe above exception was the direct cause of the following exception:\n\nself = <requests.adapters.HTTPAdapter object at 0x000001E704969090>, request = <PreparedRequest [POST]>, stream = False, timeout = Timeout(connect=30, read=30, total=None), verify = True\ncert = None, proxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n>           resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:486: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:932: in urlopen\n    retries = retries.increment(method, url, response=response, _pool=self)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None), method = 'POST', url = '/dev/persona', response = <urllib3.response.HTTPResponse object at 0x000001E70523BB80>\nerror = None, _pool = <urllib3.connectionpool.HTTPSConnectionPool object at 0x000001E704D41D30>, _stacktrace = None\n\n    def increment(\n        self,\n        method: str | None = None,\n        url: str | None = None,\n        response: BaseHTTPResponse | None = None,\n        error: Exception | None = None,\n        _pool: ConnectionPool | None = None,\n        _stacktrace: TracebackType | None = None,\n    ) -> Self:\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or method is None or not self._is_method_retryable(method):\n                raise reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            response_redirect_location = response.get_redirect_location()\n            if response_redirect_location:\n                redirect_location = response_redirect_location\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n            reason = error or ResponseError(cause)\n>           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\nE           urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/persona (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:519: MaxRetryError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <api.test_performance.TestStressScenarios object at 0x000001E70493B950>\n\n    def test_special_characters_in_requests(self):\n        \"\"\"Test endpoints with special characters\"\"\"\n        special_chars_tests = [\n            {\n                \"user_id\": \"test-user\",\n                \"message\": \"Hello! \ud83d\ude80 Testing with \u00e9mojis and a\u00e7cents\",\n            },\n            {\"user_id\": \"test-\u4e2d\u6587-user\", \"message\": \"Testing with \u4e2d\u6587 characters\"},\n            {\n                \"user_id\": \"test'quote\",\n                \"message\": \"Testing with 'quotes' and \\\"double quotes\\\"\",\n            },\n        ]\n    \n        for payload in special_chars_tests:\n>           response, data = client.post(\"/persona\", json=payload)\n\ntest_performance.py:205: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nclient.py:122: in post\n    return self.make_request(\"POST\", endpoint, **kwargs)\nclient.py:64: in make_request\n    response = self.session.request(\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:589: in request\n    resp = self.send(prep, **send_kwargs)\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:703: in send\n    r = adapter.send(request, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <requests.adapters.HTTPAdapter object at 0x000001E704969090>, request = <PreparedRequest [POST]>, stream = False, timeout = Timeout(connect=30, read=30, total=None), verify = True\ncert = None, proxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n            resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n    \n        except (ProtocolError, OSError) as err:\n            raise ConnectionError(err, request=request)\n    \n        except MaxRetryError as e:\n            if isinstance(e.reason, ConnectTimeoutError):\n                # TODO: Remove this in 3.0.0: see #2811\n                if not isinstance(e.reason, NewConnectionError):\n                    raise ConnectTimeout(e, request=request)\n    \n            if isinstance(e.reason, ResponseError):\n>               raise RetryError(e, request=request)\nE               requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/persona (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:510: RetryError"}, "teardown": {"duration": 0.0005702999987988733, "outcome": "passed"}}, {"nodeid": "test_performance.py::TestBoundaryConditions::test_empty_payloads", "lineno": 213, "outcome": "failed", "keywords": ["test_empty_payloads", "TestBoundaryConditions", "test_performance.py", "__init__.py", "api"], "setup": {"duration": 0.0005774000019300729, "outcome": "passed"}, "call": {"duration": 8.344658699999854, "outcome": "failed", "crash": {"path": "C:\\Projects\\building-os-platform\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/persona (Caused by ResponseError('too many 500 error responses'))"}, "traceback": [{"path": "test_performance.py", "lineno": 219, "message": ""}, {"path": "client.py", "lineno": 122, "message": "in post"}, {"path": "client.py", "lineno": 64, "message": "in make_request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 589, "message": "in request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 703, "message": "in send"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "RetryError"}], "stdout": "\n\ud83d\ude80 POST /persona\n\u274c Request failed: \nHTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', \nport=443): Max retries exceeded with url: /dev/persona (Caused by \nResponseError('too many 500 error responses'))\n", "longrepr": "urllib3.exceptions.ResponseError: too many 500 error responses\n\nThe above exception was the direct cause of the following exception:\n\nself = <requests.adapters.HTTPAdapter object at 0x000001E704969090>, request = <PreparedRequest [POST]>, stream = False, timeout = Timeout(connect=30, read=30, total=None), verify = True\ncert = None, proxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n>           resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:486: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:932: in urlopen\n    retries = retries.increment(method, url, response=response, _pool=self)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None), method = 'POST', url = '/dev/persona', response = <urllib3.response.HTTPResponse object at 0x000001E70523A110>\nerror = None, _pool = <urllib3.connectionpool.HTTPSConnectionPool object at 0x000001E704D41D30>, _stacktrace = None\n\n    def increment(\n        self,\n        method: str | None = None,\n        url: str | None = None,\n        response: BaseHTTPResponse | None = None,\n        error: Exception | None = None,\n        _pool: ConnectionPool | None = None,\n        _stacktrace: TracebackType | None = None,\n    ) -> Self:\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or method is None or not self._is_method_retryable(method):\n                raise reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            response_redirect_location = response.get_redirect_location()\n            if response_redirect_location:\n                redirect_location = response_redirect_location\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n            reason = error or ResponseError(cause)\n>           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\nE           urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/persona (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:519: MaxRetryError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <api.test_performance.TestBoundaryConditions object at 0x000001E7051B8550>\n\n    def test_empty_payloads(self):\n        \"\"\"Test endpoints with empty payloads\"\"\"\n        endpoints_requiring_payload = [\"/persona\", \"/elevator/call\", \"/psim/search\"]\n    \n        for endpoint in endpoints_requiring_payload:\n>           response, data = client.post(endpoint, json={})\n\ntest_performance.py:219: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nclient.py:122: in post\n    return self.make_request(\"POST\", endpoint, **kwargs)\nclient.py:64: in make_request\n    response = self.session.request(\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:589: in request\n    resp = self.send(prep, **send_kwargs)\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:703: in send\n    r = adapter.send(request, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <requests.adapters.HTTPAdapter object at 0x000001E704969090>, request = <PreparedRequest [POST]>, stream = False, timeout = Timeout(connect=30, read=30, total=None), verify = True\ncert = None, proxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n            resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n    \n        except (ProtocolError, OSError) as err:\n            raise ConnectionError(err, request=request)\n    \n        except MaxRetryError as e:\n            if isinstance(e.reason, ConnectTimeoutError):\n                # TODO: Remove this in 3.0.0: see #2811\n                if not isinstance(e.reason, NewConnectionError):\n                    raise ConnectTimeout(e, request=request)\n    \n            if isinstance(e.reason, ResponseError):\n>               raise RetryError(e, request=request)\nE               requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/persona (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:510: RetryError"}, "teardown": {"duration": 0.000534999999217689, "outcome": "passed"}}, {"nodeid": "test_performance.py::TestBoundaryConditions::test_null_values_in_payload", "lineno": 224, "outcome": "failed", "keywords": ["test_null_values_in_payload", "TestBoundaryConditions", "test_performance.py", "__init__.py", "api"], "setup": {"duration": 0.0020215999975334853, "outcome": "passed"}, "call": {"duration": 8.749967600000673, "outcome": "failed", "crash": {"path": "C:\\Projects\\building-os-platform\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/persona (Caused by ResponseError('too many 500 error responses'))"}, "traceback": [{"path": "test_performance.py", "lineno": 229, "message": ""}, {"path": "client.py", "lineno": 122, "message": "in post"}, {"path": "client.py", "lineno": 64, "message": "in make_request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 589, "message": "in request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 703, "message": "in send"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "RetryError"}], "stdout": "\n\ud83d\ude80 POST /persona\n\u274c Request failed: \nHTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', \nport=443): Max retries exceeded with url: /dev/persona (Caused by \nResponseError('too many 500 error responses'))\n", "longrepr": "urllib3.exceptions.ResponseError: too many 500 error responses\n\nThe above exception was the direct cause of the following exception:\n\nself = <requests.adapters.HTTPAdapter object at 0x000001E704969090>, request = <PreparedRequest [POST]>, stream = False, timeout = Timeout(connect=30, read=30, total=None), verify = True\ncert = None, proxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n>           resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:486: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:932: in urlopen\n    retries = retries.increment(method, url, response=response, _pool=self)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None), method = 'POST', url = '/dev/persona', response = <urllib3.response.HTTPResponse object at 0x000001E705238310>\nerror = None, _pool = <urllib3.connectionpool.HTTPSConnectionPool object at 0x000001E704D41D30>, _stacktrace = None\n\n    def increment(\n        self,\n        method: str | None = None,\n        url: str | None = None,\n        response: BaseHTTPResponse | None = None,\n        error: Exception | None = None,\n        _pool: ConnectionPool | None = None,\n        _stacktrace: TracebackType | None = None,\n    ) -> Self:\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or method is None or not self._is_method_retryable(method):\n                raise reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            response_redirect_location = response.get_redirect_location()\n            if response_redirect_location:\n                redirect_location = response_redirect_location\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n            reason = error or ResponseError(cause)\n>           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\nE           urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/persona (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:519: MaxRetryError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <api.test_performance.TestBoundaryConditions object at 0x000001E7051B8690>\n\n    def test_null_values_in_payload(self):\n        \"\"\"Test endpoints with null values\"\"\"\n        payload = {\"user_id\": None, \"message\": None}\n    \n>       response, data = client.post(\"/persona\", json=payload)\n\ntest_performance.py:229: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nclient.py:122: in post\n    return self.make_request(\"POST\", endpoint, **kwargs)\nclient.py:64: in make_request\n    response = self.session.request(\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:589: in request\n    resp = self.send(prep, **send_kwargs)\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:703: in send\n    r = adapter.send(request, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <requests.adapters.HTTPAdapter object at 0x000001E704969090>, request = <PreparedRequest [POST]>, stream = False, timeout = Timeout(connect=30, read=30, total=None), verify = True\ncert = None, proxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n            resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n    \n        except (ProtocolError, OSError) as err:\n            raise ConnectionError(err, request=request)\n    \n        except MaxRetryError as e:\n            if isinstance(e.reason, ConnectTimeoutError):\n                # TODO: Remove this in 3.0.0: see #2811\n                if not isinstance(e.reason, NewConnectionError):\n                    raise ConnectTimeout(e, request=request)\n    \n            if isinstance(e.reason, ResponseError):\n>               raise RetryError(e, request=request)\nE               requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/persona (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:510: RetryError"}, "teardown": {"duration": 0.0005814000032842159, "outcome": "passed"}}, {"nodeid": "test_performance.py::TestBoundaryConditions::test_extremely_long_mission_id", "lineno": 233, "outcome": "failed", "keywords": ["test_extremely_long_mission_id", "TestBoundaryConditions", "test_performance.py", "__init__.py", "api"], "setup": {"duration": 0.0009099000017158687, "outcome": "passed"}, "call": {"duration": 8.34482559999742, "outcome": "failed", "crash": {"path": "C:\\Projects\\building-os-platform\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/coordinator/missions/xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx (Caused by ResponseError('too many 500 error responses'))"}, "traceback": [{"path": "test_performance.py", "lineno": 238, "message": ""}, {"path": "client.py", "lineno": 119, "message": "in get"}, {"path": "client.py", "lineno": 64, "message": "in make_request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 589, "message": "in request"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py", "lineno": 703, "message": "in send"}, {"path": "..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py", "lineno": 510, "message": "RetryError"}], "stdout": "\n\ud83d\ude80 GET \n/coordinator/missions/xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n\u274c Request failed: \nHTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', \nport=443): Max retries exceeded with url: \n/dev/coordinator/missions/xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx \n(Caused by ResponseError('too many 500 error responses'))\n", "longrepr": "urllib3.exceptions.ResponseError: too many 500 error responses\n\nThe above exception was the direct cause of the following exception:\n\nself = <requests.adapters.HTTPAdapter object at 0x000001E704969090>, request = <PreparedRequest [GET]>, stream = False, timeout = Timeout(connect=30, read=30, total=None), verify = True\ncert = None, proxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n>           resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:486: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:942: in urlopen\n    return self.urlopen(\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:932: in urlopen\n    retries = retries.increment(method, url, response=response, _pool=self)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None), method = 'GET'\nurl = '/dev/coordinator/missions/xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx...xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'\nresponse = <urllib3.response.HTTPResponse object at 0x000001E705239AB0>, error = None, _pool = <urllib3.connectionpool.HTTPSConnectionPool object at 0x000001E704D41D30>, _stacktrace = None\n\n    def increment(\n        self,\n        method: str | None = None,\n        url: str | None = None,\n        response: BaseHTTPResponse | None = None,\n        error: Exception | None = None,\n        _pool: ConnectionPool | None = None,\n        _stacktrace: TracebackType | None = None,\n    ) -> Self:\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or method is None or not self._is_method_retryable(method):\n                raise reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            response_redirect_location = response.get_redirect_location()\n            if response_redirect_location:\n                redirect_location = response_redirect_location\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n            reason = error or ResponseError(cause)\n>           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\nE           urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/coordinator/missions/xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:519: MaxRetryError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <api.test_performance.TestBoundaryConditions object at 0x000001E704E2CD60>\n\n    def test_extremely_long_mission_id(self):\n        \"\"\"Test coordinator with very long mission ID\"\"\"\n        long_mission_id = \"x\" * 1000  # 1000 character mission ID\n    \n>       response, data = client.get(f\"/coordinator/missions/{long_mission_id}\")\n\ntest_performance.py:238: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nclient.py:119: in get\n    return self.make_request(\"GET\", endpoint, **kwargs)\nclient.py:64: in make_request\n    response = self.session.request(\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:589: in request\n    resp = self.send(prep, **send_kwargs)\n..\\..\\.venv\\Lib\\site-packages\\requests\\sessions.py:703: in send\n    r = adapter.send(request, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <requests.adapters.HTTPAdapter object at 0x000001E704969090>, request = <PreparedRequest [GET]>, stream = False, timeout = Timeout(connect=30, read=30, total=None), verify = True\ncert = None, proxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n            resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n    \n        except (ProtocolError, OSError) as err:\n            raise ConnectionError(err, request=request)\n    \n        except MaxRetryError as e:\n            if isinstance(e.reason, ConnectTimeoutError):\n                # TODO: Remove this in 3.0.0: see #2811\n                if not isinstance(e.reason, NewConnectionError):\n                    raise ConnectTimeout(e, request=request)\n    \n            if isinstance(e.reason, ResponseError):\n>               raise RetryError(e, request=request)\nE               requests.exceptions.RetryError: HTTPSConnectionPool(host='pj4vlvxrg7.execute-api.us-east-1.amazonaws.com', port=443): Max retries exceeded with url: /dev/coordinator/missions/xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx (Caused by ResponseError('too many 500 error responses'))\n\n..\\..\\.venv\\Lib\\site-packages\\requests\\adapters.py:510: RetryError"}, "teardown": {"duration": 0.15168540000013309, "outcome": "passed", "stdout": "\n\ud83d\udcca Test Session Complete\n                              \ud83d\udd0d Request Summary                               \n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Method \u2502 Endpoint                            \u2502 Status \u2502 Time (ms) \u2502 Success \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 1916.16   \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 211.21    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /director                           \u2502 0      \u2502 9223.28   \u2502 \u274c      \u2502\n\u2502 GET    \u2502 /director?user_request=Test mission \u2502 0      \u2502 8414.11   \u2502 \u274c      \u2502\n\u2502        \u2502 from Python API tests               \u2502        \u2502           \u2502         \u2502\n\u2502 GET    \u2502 /director?user_id=api-test-user     \u2502 0      \u2502 8375.82   \u2502 \u274c      \u2502\n\u2502 POST   \u2502 /persona                            \u2502 0      \u2502 9100.85   \u2502 \u274c      \u2502\n\u2502 POST   \u2502 /persona                            \u2502 0      \u2502 8233.31   \u2502 \u274c      \u2502\n\u2502 POST   \u2502 /persona                            \u2502 0      \u2502 8284.69   \u2502 \u274c      \u2502\n\u2502 GET    \u2502 /persona/conversations?user_id=api\u2026 \u2502 0      \u2502 8208.23   \u2502 \u274c      \u2502\n\u2502 POST   \u2502 /elevator/call                      \u2502 0      \u2502 8295.67   \u2502 \u274c      \u2502\n\u2502 POST   \u2502 /elevator/call                      \u2502 0      \u2502 7741.51   \u2502 \u274c      \u2502\n\u2502 POST   \u2502 /psim/search                        \u2502 0      \u2502 8306.19   \u2502 \u274c      \u2502\n\u2502 POST   \u2502 /psim/search                        \u2502 0      \u2502 7713.22   \u2502 \u274c      \u2502\n\u2502 GET    \u2502 /coordinator/missions/test-mission\u2026 \u2502 0      \u2502 9337.6    \u2502 \u274c      \u2502\n\u2502 GET    \u2502 /coordinator/missions/python-test-\u2026 \u2502 0      \u2502 8391.87   \u2502 \u274c      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 210.33    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /director                           \u2502 0      \u2502 8734.58   \u2502 \u274c      \u2502\n\u2502 POST   \u2502 /persona                            \u2502 0      \u2502 8310.6    \u2502 \u274c      \u2502\n\u2502 POST   \u2502 /elevator/call                      \u2502 0      \u2502 7691.33   \u2502 \u274c      \u2502\n\u2502 POST   \u2502 /psim/search                        \u2502 0      \u2502 7793.64   \u2502 \u274c      \u2502\n\u2502 GET    \u2502 /coordinator/missions/test-123      \u2502 0      \u2502 8340.02   \u2502 \u274c      \u2502\n\u2502 GET    \u2502 /invalid-endpoint                   \u2502 404    \u2502 189.11    \u2502 \u274c      \u2502\n\u2502 DELETE \u2502 /health                             \u2502 404    \u2502 169.06    \u2502 \u274c      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 195.88    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /director                           \u2502 0      \u2502 8485.65   \u2502 \u274c      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 205.46    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 1705.34   \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 1841.45   \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 1856.5    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 1897.37   \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 208.38    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 196.04    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 841.07    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 188.78    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 195.29    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 195.93    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 191.06    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 195.59    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 189.74    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 201.68    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 215.63    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 302.97    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 943.74    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 201.71    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 215.4     \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 189.56    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 712.23    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 198.32    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 194.62    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 189.63    \u2502 \u2705      \u2502\n\u2502 POST   \u2502 /persona                            \u2502 0      \u2502 10673.9   \u2502 \u274c      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 199.88    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 192.39    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 200.09    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 195.44    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 201.54    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 360.98    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 303.71    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 192.32    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 197.37    \u2502 \u2705      \u2502\n\u2502 GET    \u2502 /health                             \u2502 200    \u2502 496.08    \u2502 \u2705      \u2502\n\u2502 POST   \u2502 /persona                            \u2502 0      \u2502 8384.99   \u2502 \u274c      \u2502\n\u2502 POST   \u2502 /persona                            \u2502 0      \u2502 8341.72   \u2502 \u274c      \u2502\n\u2502 POST   \u2502 /persona                            \u2502 0      \u2502 8747.19   \u2502 \u274c      \u2502\n\u2502 GET    \u2502 /coordinator/missions/xxxxxxxxxxxx\u2026 \u2502 0      \u2502 8335.28   \u2502 \u274c      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Performance Metrics \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 \ud83d\udcc8 Avg: 475.56ms | \u26a1 Min: 188.78ms | \ud83d\udc0c Max: 1916.16ms                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\ud83d\udcbe Results exported to: api-test-results-20250809-181250.json\n"}}], "warnings": [{"message": "Unknown pytest.mark.slow - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html", "category": "PytestUnknownMarkWarning", "when": "collect", "filename": "c:\\Projects\\building-os-platform\\tests\\api\\test_performance.py", "lineno": 73}, {"message": "Unknown pytest.mark.slow - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html", "category": "PytestUnknownMarkWarning", "when": "collect", "filename": "c:\\Projects\\building-os-platform\\tests\\api\\test_performance.py", "lineno": 245}, {"message": "Unknown pytest.mark.load - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html", "category": "PytestUnknownMarkWarning", "when": "collect", "filename": "c:\\Projects\\building-os-platform\\tests\\api\\test_performance.py", "lineno": 246}]}